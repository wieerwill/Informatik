\documentclass[a4pape]{article}
\usepackage[ngerman]{babel}
\usepackage{multicol}
\usepackage{calc}
\usepackage{ifthen}
\usepackage[landscape,left=1cm,top=1cm,right=1cm,nohead,nofoot]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb}
\usepackage{color,graphicx,overpic}
\usepackage{listings}
\usepackage[compact]{titlesec} %less space for headers
\usepackage{mdwlist} %less space for lists
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{pdflscape}
\usepackage{verbatim}
\usetikzlibrary{mindmap}
\usepackage[hidelinks,pdfencoding=auto]{hyperref}

\pdfinfo{
    /Title (Betriebssysteme - Cheatsheet)
    /Creator (TeX)
    /Producer (pdfTeX 1.40.0)
    /Author (Robert Jeutter)
    /Subject ()
}
% Information boxes
\newcommand*{\info}[4][16.3]{
  \node [ annotation, #3, scale=0.65, text width = #1em, inner sep = 2mm ] at (#2) {
  \list{$\bullet$}{\topsep=0pt\itemsep=0pt\parsep=0pt
    \parskip=0pt\labelwidth=8pt\leftmargin=8pt
    \itemindent=0pt\labelsep=2pt}
    #4
  \endlist
  };
}

% This sets page margins to .5 inch if using letter paper, and to 1cm
% if using A4 paper. (This probably isn't strictly necessary.)
% If using another size paper, use default 1cm margins.
\ifthenelse{\lengthtest { \paperwidth = 11in}}
    { \geometry{top=.5in,left=.5in,right=.5in,bottom=.5in} }
    {\ifthenelse{ \lengthtest{ \paperwidth = 297mm}}
        {\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm} }
        {\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm} }
    }

% Turn off header and footer
\pagestyle{empty}

% Redefine section commands to use less space
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%x
                                {\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
                                {-1explus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%
                                {\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {1ex plus .2ex}%
                                {\normalfont\small\bfseries}}
\makeatother

% Define BibTeX command
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

% Don't print section numbers
\setcounter{secnumdepth}{0}


\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}    
% compress space
\setlength\abovedisplayskip{0pt}
\setlength{\parskip}{0pt}
\setlength{\parsep}{0pt}
\setlength{\topskip}{0pt}
\setlength{\topsep}{0pt}
\setlength{\partopsep}{0pt}
\linespread{0.5}
\titlespacing{\section}{0pt}{*0}{*0}
\titlespacing{\subsection}{0pt}{*0}{*0}
\titlespacing{\subsubsection}{0pt}{*0}{*0}

%My Environments
\newtheorem{example}[section]{Example}
% -----------------------------------------------------------------------


%%%% Predefined Colors: black, blue, brown, cyan, darkgray, gray, green, lightgray, lime, magenta, olive, orange, pink, purple, red, teal, violet, white, yellow.

\pagestyle{empty}
\begin{document}


\raggedright
\begin{multicols}{3}\scriptsize
  % multicol parameters
  % These lengths are set only within the two main columns
  %\setlength{\columnseprule}{0.25pt}
  \setlength{\premulticols}{1pt}
  \setlength{\postmulticols}{1pt}
  \setlength{\multicolsep}{1pt}
  \setlength{\columnsep}{2pt}

  \paragraph{Prozesse}
  \begin{itemize*}
    \item Betriebssystem-Abstraktionen zur Ausführung von Programmen
    \item Eigentümer von Ressourcen
    \item differenzierte Prozessmodelle: definieren konkrete Prozesseigenschaften
  \end{itemize*}

  \paragraph{Prozessmanagement}
  \begin{itemize*}
    \item Komponente eines Betriebssystems, die Prozessmodell dieses Betriebssystems implementiert
    \item wichtige Aufgaben: Prozesserzeugung u. -beendigung (u. Scheduling)
    \item wichtigste Datenstrukturen: Prozessdeskriptor, Prozessdeskriptortabelle
  \end{itemize*}

  \paragraph{Prozessdeskriptor (PCB)}
  Buchführung über sämtliche zum Management eines Prozesses notwendigen Informationen
  \begin{itemize*}
    \item Prozessidentifikation
    \item Rechtemanagement
    \item Speichermanagement
    \item Prozessormanagement
    \item Kommunikationsmanagement
  \end{itemize*}

  \paragraph{Prozessdeskriptortabelle}
  enthält: Prozessdeskriptoren aller momentan existierenden Prozesse

  \paragraph{Threads}
  \begin{itemize*}
    \item Betriebssystem-Abstraktionen für sequentielle, nebenläufige Aktivitäten
    \item sind Gegenstand des Schedulings
  \end{itemize*}

  \paragraph{Multithread-Prozessmodell}
  \begin{itemize*}
    \item vollständige Beschreibung einer ablaufenden Aktivität
    \item Dazu gehören insbesondere
    \begin{enumerate*}
      \item das ablaufende Programm
      \item zugeordnete Betriebsmittel (Prozessor/Speicher/Kommunikation)
      \item Rechte
      \item prozessinterne parallele Aktivitäten (Threads) und deren Bearbeitungszustände
    \end{enumerate*}
  \end{itemize*}

  \paragraph{Threaddeskriptor (TCB)}
  \begin{itemize*}
    \item ein TCB enthält lediglich:
    \begin{enumerate*}
      \item Threadzustand (aktiv, bereit, blockiert, ...)
      \item Ablaufkontext, falls nicht aktiv (Programmzähler, Stackpointer, Prozessorregister)
    \end{enumerate*}
    \item enthält nicht: Beschreibung der Ressourcen (Speicherlayout, Rechte)
  \end{itemize*}

  \paragraph{Thread-Typen}
  \begin{itemize*}
    \item Kernel Level Threads (KLTs): Kenntnis über Threads: hat Betriebssystem, genauer: der Betriebssystem-Kern(el)
    \item User Level Threads (ULTs): Kenntnis über Threads: existiert nur auf Benutzer-Ebene (user level)
    \item das Betriebssystem [genauer: der Betriebssystem-Kern(el)] weiß nicht, dass Threads existieren
  \end{itemize*}

  \paragraph{Scheduling: Grundaufgabe}
  Entscheidung: Welche Threads erhalten wann u. wie lange einen Prozessor/Prozessorkern zugeteilt?

  \paragraph{Zustandsmodelle}
  \begin{itemize*}
    \item Threads können verschiedene Zustände annehmen (Beispiel 3/5-Zustandsmodell)
    \item bereit, aktiv, blockiert, frisch, beendet
  \end{itemize*}
  \centering{
    \includegraphics[width=\textwidth/4]{Assets/Betriebssysteme_Zustandsmodell.png}
  }

  \paragraph{Scheduling: Notwendigkeit u. Sinn}
  \begin{itemize*}
    \item im Allgemeinen: Anzahl der Aktivitäten >> Anzahl der Prozessoren
    \item nicht alle können gleichzeitig arbeiten
    \item eine Auswahl muss getroffen werden
    \item Auswahlstrategie: Schedulingstrategie, ~algorithmus
    \item die Betriebssystemkomponente: Scheduler
  \end{itemize*}

  \paragraph{Scheduling-Strategien}
  \begin{itemize*}
    \item abhängig vom Einsatzfeld eines Betriebssystems
    \begin{itemize*}
      \item Echtzeitsysteme: Einhaltung von Fristen
      \item interaktive Systeme: Reaktivität
    \end{itemize*}
    \item wichtige Strategien:
    \begin{itemize*}
      \item FCFS
      \item SRTN
      \item Round Robin (ohne u. mit Prioritäten)
      \item EDF
      \item ratenmonotones Scheduling
    \end{itemize*}
  \end{itemize*}

  \paragraph{Privilegierungsebenen}
  \begin{itemize*}
    \item sind typischerweise "kernel mode" und "user mode"
    \item steuern Rechte ...
    \begin{itemize*}
      \item zur Ausführung privilegierter Prozessorinstruktionen
      \item zur Konfiguration des Arbeitsspeicherlayouts
      \item zum Zugriff auf Arbeitsspeicherbereiche
      \item zum Zugriff auf E/A-Geräte
    \end{itemize*}
    \item ermöglichen: Durchsetzung von Regeln: "Nur ein im 'kernel mode' ablaufender Prozess hat Zugriff auf ..."
  \end{itemize*}

  \paragraph{Kommunikation u. Synchronisation}
  \begin{itemize*}
    \item Austausch von Daten zwischen Prozessen = Kommunikation (Inter-Prozess-Kommunikation, IPC)
    \item Abweichende Geschwindigkeiten von Sender und Empfänger: behandelt durch Synchronisation
  \end{itemize*}

  \paragraph{kritischer Abschnitt und wechselseitiger Ausschluss}
  \begin{itemize*}
    \item in einem kritischen Abschnitt darf sich stets nur ein Thread aufhalten
    \item notwendig: wechselseitiger (gegenseitiger) Ausschluss
    \item realisiert durch Entry- u. Exit-Code [z.B. die Semaphor-Operationen belegen (P) und freigeben (V)]
  \end{itemize*}

  \paragraph{Mechanismen zur Synchronisation}
  \begin{itemize*}
    \item Semaphore (binäre Semaphore u. mehrwertige Semaphore) (ansehen!)
    \item (Hoar‘sche) Monitore
  \end{itemize*}

  \paragraph{Mechanismen zur Kommunikation}
  \begin{itemize*}
    \item Shared Memory (gemeinsamer Speicher)
    \item Botschaften
    \item Fernaufrufe
    \item Systemaufrufe
  \end{itemize*}

  \paragraph{Notwendigkeit des Ereignismanagement}
  \begin{itemize*}
    \item in Betriebssystemen laufen sehr viele Aktivitäten parallel ab
    \item dabei entstehen immer wieder Situationen, in denen auf unterschiedlichste Ereignisse reagiert werden muss, z.B.
    \begin{itemize*}
      \item Timerablauf
      \item Benutzereingaben (Maus, Tastatur)
      \item Eintreffen von Daten von Netzwerken, Festplatten, ...
      \item Einlegen/stecken von Datenträgern
      \item Aufruf von Systemdiensten
      \item Fehlersituationen
    \end{itemize*}
  \end{itemize*}

  \paragraph{Umgangsformen mit Ereignissen}
  \begin{itemize*}
    \item "busy waiting"
    \item "periodic testing"
    \item Unterbrechungen ("Interrupts")
  \end{itemize*}

  \paragraph{Programmiermodelle zum Umgang mit Interrupts}
  \begin{itemize*}
    \item Prozeduren (→ inline Prozeduraufrufmodell)
    \item IPC-Operationen (→ IPC-Modell)
    \item Threads (→ pop-up Thread Modell)
  \end{itemize*}

  \paragraph{Interrupts auf Anwendungsebene}
  \begin{itemize*}
    \item notwendig: Event Service Routines (ESRs)
    \item Beispiel: UNIX/Linux-Signalbehandlung
  \end{itemize*}

  \paragraph{Virtuelle Prozessadressräume und physischer Adressraum, Abbildungen}
  \centering{
    \includegraphics[width=\textwidth/4]{Assets/Betriebssysteme_Adressräume.png}
  }

  \paragraph{Seitenabbildungstabellen}
  \centering{
    \includegraphics[width=\textwidth/4]{Assets/Betriebssysteme_Seitenabbildungstabellen.png}
  }

  \paragraph{Seitentabelleneinträge}
  \centering{
    \includegraphics[width=\textwidth/4]{Assets/Betriebssysteme_Seitentabelleneinträge.png}
  }
  \begin{itemize*}
    \item anwesend:Indikator, ob Seite im Arbeitsspeicher liegt ("present"-Bit)
    \item benutzt: Indikator, ob auf die Seite zugegriffen wurde ("used/referenced"-Bit)
    \item verändert: Indikator, ob Seite "schmutzig" ist ("dirty/modified"-Bit)
    \item Schutz: erlaubte Zugriffsart je Privilegierungsebene ("access control list")
    \item Caching: Indikator, ob Inhalt der Seite ge"cached" werden darf
  \end{itemize*}

  \paragraph{Seitenaustauschalgorithmen}
  \begin{itemize*}
    \item Optimale Strategie: Auslagerung derjenigen Arbeitsspeicherseite, deren ...
    \begin{itemize*}
      \item nächster Gebrauch am weitesten in der Zukunft liegt ("Hellseher")
      \item Auslagerung nichts kostet (man müsste man wissen, ob eine Seite seit ihrer Einlagerung verändert wurde)
    \end{itemize*}
    \item im Folgenden: einige Algorithmen, die sich diesem Optimum annähern:
    \begin{itemize*}
      \item First-In, First-Out (FIFO)
      \item Second-Chance
      \item Least Recently Used (LRU)
      \item Working Set / WSClock
    \end{itemize*}
  \end{itemize*}

  \paragraph{i-Node}
  i-Node: Metainformationen über genau eine Datei
  \centering{
    \includegraphics[width=\textwidth/4]{Assets/Betriebssysteme_i-Node.png}
  }

  \paragraph{Verzeichnis}
  Verzeichnis = Menge von Paaren (Name, i-Node-Index)

  \paragraph{Superblock}
  \begin{itemize*}
    \item Superblock: Einstiegspunkt eines Dateisystems
    \item enthält: Schlüsselparameter
    \begin{itemize*}
      \item Name des Dateisystems
      \item Typ (NTFS, Ext * , HFS, ...) → Layout der Metadaten
      \item Größe und Anzahl Sektoren
      \item Ort und Größe der i-Node-Tabelle
      \item Ort und Größe der Freiliste
      \item i-Node-Nummer des Wurzelverzeichnisses
    \end{itemize*}
  \end{itemize*}

  \paragraph{Hardware-Prinzipien}
  \begin{itemize*}
    \item\item Controller-Register
    \begin{itemize*}
      \item\item in E/A-Adressräumen
      \item im Arbeitsspeicher (Memory Mapped E/A)
      \item Isolation, Robustheit, Sicherheit
    \end{itemize*}
    \item Interruptsystem: asynchrone Benachrichtigungen
  \end{itemize*}

  \paragraph{Software-Prinzipien}
  Gerätemanager (Treiber)
  \begin{itemize*}
    \item\item Auftragsmanagement
    \item ISRs
  \end{itemize*}

  \paragraph{Betriebssystem-Architekturen}
  \centering{
    \includegraphics[width=\textwidth/4]{Assets/Betriebssysteme_Architekturen.png}
  }

  \paragraph{Sicherheit}
  \begin{itemize*}
    \item\item Schutz des Betriebssystems
    \item z.B. gegen Angriffe von außen
  \end{itemize*}

  \paragraph{SELinux-Ansatz}
  \begin{itemize*}
    \item\item Sicherheitspolitiken in SELinux
    \item neue Betriebssystem-Abstraktion
    \begin{itemize*}
      \item\item absolute Kontrolle über kritische Funktionen des Betriebssystems
      \item spezifiziert durch Regelmenge
      \item implementiert durch die SELinux-Sicherheitsarchitektur
    \end{itemize*}
  \end{itemize*}

  \paragraph{Robustheit}
  \begin{itemize*}
    \item Ziel: Tolerierung unvorhergesehener Fehler und Ausfälle
    \item Mikrokernarchitekturen: robuster als Makrokernarchitekturen
    \item Gründe:
    \begin{itemize*}
      \item\item Fehlerisolation
      \item Möglichkeiten zur Fehlerbehebung (z.B. Micro-Reboot)
    \end{itemize*}
  \end{itemize*}


\end{multicols}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Überblick
\begin{tikzpicture}[ mindmap, grow cyclic, every node/.style=concept, concept color=black!10,
    level 1/.append style={level distance=4cm},
    level 2/.append style={level distance=3cm, sibling angle=30},
    every node/.append style={scale=0.8}]

  \node{Betriebssysteme}
  child [concept color=red!30]{ node {Prozessor-management}
      child { node {Prozess-erzeugung}}
      child { node {Prozess-terminierung}}
      child { node {Threads}}
    }
  child [concept color=green!30]{ node {Scheduling}
      child { node {Scheduler-aktivierung}}
      child { node {Scheduling Strategien}}
    }
  child [concept color=blue!30]{ node {Privilegierungs-ebenen}}
  child [concept color=yellow!30]{ node {Kommunikation und\\Synchronisation}
      child { node {Elementare Konzepte}}
      child { node {wechselseitiger Ausschluss}}
      child { node {Mechanismen}}
    }
  child [concept color=orange!30]{ node {Speicher-management}
      child { node {Speicher-technologien}}
      child { node {Speicher-klassen}}
      child { node {Relokation}}
      child { node {Swapping}}
      child { node {Virtueller Speicher}}
      child { node {Segmentierung}}
    }
  child [concept color=lime!30]{ node {Dateisystem}
      child { node {Dateimodelle}}
      child { node {Dateisysteme}}
      child { node {Datenstrukturen \& Algorithmen}}
    };
\end{tikzpicture}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Grundbegriffe
\begin{tikzpicture}[ mindmap, grow cyclic, every node/.style=concept, concept color=black!40,
    level 1/.append style={level distance=4cm, sibling angle=120},
    level 2/.append style={level distance=3cm, sibling angle=30},
    every node/.append style={scale=0.8}]
  \node{Grundbegriffe}
  child[concept color=red!30]{node{Funktionale Eigenschaften}
      child{node{Authentisierung, Verschlüsselung}}
      child{node{Informations-management}}
      child{node{Kommunikations-management}}
      child{node{Ressourcen-management}}
    }
  child[concept color=green!30]{node{Nichtfunktionale Eigenschaften}
      child{node{Sicherheit}}
      child{node{Korrektheit}}
      child{node{Echtzeitfähigkeit}}
      child{node{Skalierbarkeit}}
      child{node{Offenheit}}
      child{node{Sparsamkeit}}
      child{node{Verfügbarkeit}}
      child{node{Robustheit}}
    }
  child[concept color=blue!30]{node{Betriebssysteme}
      child{ node {Mainframe}
          child{ node {performante E/A}}
          child{ node {Massen-daten-verarbeitung}}
        }
      child{ node {Server}
          child{ node {Web Server, Fileshare}}
        }
      child{ node {Parallelrechner}
          child{ node {parallele Algorithmen, hoher Rechenbedarf}}
          child{ node {schnelle IPC}}
        }
      child{ node {Desktop/Laptop}
          child{ node {Interaktivität \& Responsivität}}
        }
      child{ node {Echtzeit}
          child{ node {Einhaltung zeitlicher Garantien}}
          child{ node {Fahrzeug-, Anlagensteuerung}}
        }
      child{ node {Eingebettete}
          child{ node {Controller, Kaffeemaschinen,...}}
        }
    }
  ;
\end{tikzpicture}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Prozessormanagement
\begin{tikzpicture}[ mindmap, grow cyclic, every node/.style=concept, concept color=red!40,
    level 1/.append style={level distance=4cm, sibling angle=90},
    level 2/.append style={level distance=3cm, sibling angle=35},
    every node/.append style={scale=0.8}]
  \node{Prozessor-management}
  child[concept color=blue!30]  { node {Prozess-erzeugung}
      child { node {Vorraussetzungen}
          child { node {Rechte}}
          child{ node {Ressourcen Verfügbar}}
          child{ node {Sicherheit}}
          child{ node{Fariness}}
          child{node{Robustheit / Überlastungsvermeidung}}
        }
      child { node {Namens-vergabe}
          child{node{eindeutig bzgl allen existierenden}}
          child{node{nicht eindeutig bzgl allen}}
        }
      child { node {Stammbaum-pflege}
          child{node{erzeugt Kinder}}
          child{node{baumartige Hierarchie}}
          child{node{Verwaiste Prozesse -> Adoption}}
        }
      child { node {Allokation (von Ressourcen)}
          child{node{Arbeits-speicher}
              child{node{Größe}}
              child{node{Zeitpunkt}}
            }
          child{node{Prozessorzeit}}
          child{node{Format}
              child{node{a.out (ehem UNIX)}}
              child{node{Mach Object (iOS)}}
              child{node{Executeable and Link(age/able) (Linux)}}
            }
        }
    }
  child[concept color=red!30]  { node {Prozess Management}
      child{node{Prozess-identifikation}}
      child{node{Scheduling}}
      child{node{Ereignis-management}}
      child{node{Rechte-management}}
      child{node{Speicher-management}}
      child{node{Prozessor-management}}
      child{node{Kommu-nikations-management}}
      child{node{Virtueller Adressraum}}
      child{node{allg Ressourcen Management}}
    }
  child[concept color=green!30]  { node {Prozess-terminierung}
      child{node{durch}
          child{node{Aufgabe erledigt}}
          child{node{Fehler aufgetreten}}
          child{node{durch Nutzer geschlossen}}
        }
      child{node{Folgen}
          child{node{Freigabe der Ressourcen}}
          child{node{Benachrichtigung der "Parents"}}
          child{node{Adoption der "Children"}}
        }
    }
  child[concept color=yellow!30]  { node {Threads}
      child{node{sequenziell innerhalb eines Prozesses}}
      child{node{Kernel Level Thread}
          child{node{Implementiert im Betriebssystem}}
          child{node{Betriebssystem hat Kenntnis über Thread}}
          child{node{Multi-Thread-modell}}
          child{node{Performance durch Parallelität}}
          child{node{Nutzung von Mehrkern-architektur}}
        }
      child{node{User Level Thread}
          child{node{Implementiert auf Anwendungsebene}}
          child{node{Kenntnis nur bei Endbenutzer}}
          child{node{Single-Thread-Modell}}
          child{node{Performance durch geringen Overhead}}
          child{node{management ohne systemaufrufe}}
          child{node{Individualität}}
          child{node{Portabilität}}
        }
    };
\end{tikzpicture}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Scheduling
\begin{tikzpicture}[ mindmap, grow cyclic, every node/.style=concept, concept color=green!40,
    level 1/.append style={level distance=4cm},
    level 2/.append style={level distance=3cm, sibling angle=30},
    every node/.append style={scale=0.8}]
  \node{Scheduling}
  child { node {Aktivierung}
      child{node{Threadzustände im 3/5 Modell}
          child{node{bereit: kann aktiv werden}}
          child{node{aktiv: arbeitet}}
          child{node{blockiert: wartet auf Ereignis}}
          child{node{frisch: erzeugt, Rechte fehlen}}
          child{node{beendet: in Freigabephase}}
        }
      child{node{Entscheidung Überprüfen bei}
          child{node{Prozess/Thread Erzeugung/Terminierung}}
          child{node{Ereignis eintritt}}
          child{node{Wechsel von Prioritäten}}
          child{node{periodisch}}
        }
    }
  child{node{Ziele}
      child{node{abhängig von Einsatz des Betriebssystems}}
      child{node{ergänzt durch allg Ziele}}
      child{node{Einhaltung von Fristen}}
      child{node{Minimieren der Thread/Prozess-wechsel}}
    }
  child { node {Scheduling Strategien}
      child { node {Batch-System}
          child{node{Auslastung teurer Betriebsmittel (CPU)}}
          child{node{Minimierung der Scheduling Kosten (wenig Wechsel, kurze Laufzeiten)}}
          child{node{Maximierung des Durchsatzes (erledigte Arbeit/Zeit)}}
          child{node{First Come First Served}
              child{node{in Reihenfolge der rechenbereiten}}
              child{node{sehr einfach, guter durchsatz}}
              child{node{nicht immer klug}}
            }
          child{node{Shortest Remaining Time Next}
              child{node{Thread mit vorr. kürzester Restrechenzeit}}
              child{node{preemtiv; konkurrrierende Threads verdrängen}}
              child{node{Restlaufzeit muss vorliegen}}
            }
        }
      child { node {Interaktives System}
          child{node{Benutzer kann eingreifen}}
          child{node{Minimierung von Reaktionszeiten}}
          child{node{Fairness (mehrere Benutzer)}}
          child{node{Round Robin Varianten}
              child{node{jeder Thread gleicher Teil der Zeitscheibe}}
              child{node{einfach zu implementieren}}
              child{node{geringe Algorithmuskosten}}
              child{node{schnelle Entscheidungen}}
              child{node{geringes Wissen notwendig}}
            }
        }
    }
  child{node{Prioritäten}
      child{node{jeder Thread erhält indv. Priorität}}
      child{node{höchste Prioritäten erhalten Prozessor}}
      child{node{gleiche Priorität: Round Robin}}
    }
  child{node{in Echtzeitsystemen}
      child{node{EDF: earliest deadline first}
          child{node{dynamische Lasten; adaptiv}}
          child{node{Threads nennen Deadline/Frist}}
          child{node{kausale und zeitliche Unabhängigkeit}}
          child{node{Priorität setzt kürzere Fristen}}
        }
      child{node{RMS: rate-monotonic scheduling}
          child{node{periodische Lasten}}
          child{node{Threads nennen Periodendauer}}
          child{node{kürzeste Periodendauer aktiv}}
          child{node{statische Prioritäten}}
        }
    };
\end{tikzpicture}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Privilegierungsebenen
\begin{tikzpicture}[ mindmap, grow cyclic, every node/.style=concept, concept color=blue!40,
    level 1/.append style={level distance=4cm},
    level 2/.append style={level distance=3cm, sibling angle=30},
    every node/.append style={scale=0.8}]
  \node{Privilegierungsebenen}
  child{node{Konzepte}
      child{node{private Adressräume}}
      child{node{Zugriffsschutz auf Arbeitsspeicherbereiche}}
    }
  child{node{kritische Operationen}
      child{node{Abschalten der Uhr}}
      child{node{Abschalten des Ereignismanagement}}
      child{node{Veränderung des Speicherlayouts}}
      child{node{Veränderng kritischer Prozessorkontrollregister}}
      child{node{Zugriff auf E/A Geräte}}
    }
  child{node{P. Ebenen}
      child{node{steuern Rechte}
          child{node{zur Ausführung privilegierter Prozessorinstruktionen}}
          child{node{zur Konfiguration des Arbeitsspeicher-Layouts}}
          child{node{zum Zugriff auf Arbeitsspeicherbereiche}}
          child{node{zum Zugriff auf E/A-Geräte}}
        }
      child{node{realisiert in Ringen (0-3)}}
    }
  child{node{Implementierung}
      child{node{Hardware Unterstützung}}
      child{node{Teil "Current Privilege Level" (CPL)}}
      child{node{permantente Überwachung}}
      child{node{Änderung der CPL beschränken}}
    }
  child{node{Botschaften}
      child{node{P.E. < 3 ablaufende Aktivität hat Zugriff auf kritische Ressourcen}}
      child{node{P.E. 0 ablaufende Aktivität hat Zugriff auf}
          child{node{Ressourcen eines Prozessors}}
          child{node{MMU-Register zur Arbeitsspeicherkonfiguration}}
          child{node{Register der E/A-Peripherie}}
        }
    };
\end{tikzpicture}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Kommunikation und Synchronisation
\begin{tikzpicture}[ mindmap, grow cyclic, every node/.style=concept, concept color=yellow!40,
    level 1/.append style={level distance=4cm},
    level 2/.append style={level distance=3cm, sibling angle=30},
    every node/.append style={scale=0.8}]
  \node{Kommunikation und \\Synchronisation}
  child { node {Elementare Konzepte}
      child{node{Ziel}
          child{node{nur 1 Thread darf zu einem Zeitpunkt mit best. Speicherbereich arbeiten}}
          child{node{erst nach beendigung, darf ein anderer Thread damit arbeiten}}
        }
      child{node{Austausch von Daten zwischen Prozessen $\rightarrow$ Kommunikation}}
      child{node{Abweichende Geschwindigkeiten von Sender und Empfänger $\rightarrow$ Synchronisation}}
      child{node{Eine Phase, in der ein Thread eine exklusive Operation auf einer Ressource ausführt, heißt kritischer Abschnitt.}}
      child{node{Kritische Abschnitte erfordern den wechselseitigen Ausschluss (die Isolation) konkurrierender Threads bzw. Prozesse.}}
    }
  child { node {wechselseitiger Ausschluss}
      child{node{Korrektheit: in kritischen Abschnitt höchstens ein Thread}}
      child{node{Lebendigkeit: Falls ein Thread einen kritischen Abschnitt betreten möchte, dann betritt (irgendwann) ein Thread diesen Abschnitt.}}
      child{node{Verhungerungsfreiheit: Kein Thread wartet für immer vor einem kritischen Abschnitt}}
    }
  child { node {Mechanismen}
      child { node {(binäre) Semaphore}
          child{node{2 Zustände: frei, belegt}}
          child{node{2 atomare Operationen}
              child{node{belegen: P}}
              child{node{freigeben: V}}
            }
          child{node{Sämtliche Nutzer dieses kritischen Abschnitts müssen diese semaphore verwenden}}
          child{node{Unterstützung durch Hardware: die TSL-Operation (TestAndSetLock)}}
          child{node{Implementierung im Ressourcenmanagement}}
          child{node{Mehrwertiger Semaphor (oder Zählsemaphor) mit mehreren Semaphoren; maximaler Sem-Wert = n, bestimmt maximale Anzahl von Threads, die gleichzeitig aktiv sein können}}
        }
      child { node {Hoare'sche Monitore}
          child{node{Zusammenfassen von Daten/Operationen/Zugriff zu abstrakten Datentyp}}
          child{node{Zugriff auf Daten über implizit synchronisierende Operation}}
          child{node{kritischer Abschnitt und Daten in durch Monitor geschütztem Bereich}}
          child{node{wechselseitiger Ausschluss}
              child{node{Türsteher an Eingang \& Ausgang}}
              child{node{Betreten nur mit Monitor Zustimmung}}
              child{node{falls Thread in Monitor aktiv, kein weiterer rein (P)}}
              child{node{falls Thread Monitor verlässt, Wartenden rein (V)}}
              child{node{Threads Verlassen statt Warten im Monitor}}
            }
          child{node{je Monitor eine Semaphor}}
          child{node{am Eingang eine P-Operation}}
          child{node{am Ausgang eine V-Operation}}
        }
    }
  child { node {weitere}
      child { node {Trans-aktionaler Speicher}
          child{node{keine Sperre bei Ausschluss $\rightarrow$ Parallelität}}
          child{node{nach Operation untersuchen auf Fehler und Korrektur}}
          child{node{Kombination mit Transaktionen}}
        }
      child { node {Botschaften}
          child{node{für Kommunikation zwischen}}
          child{node{Prozessen innerhalb eines Systems}}
          child{node{Anwendungsprozessen}}
          child{node{Senden/Empfangen von Botschaften}}
          child{node{Kommunikationsparadigma}}
        }
      child { node {Fernaufrufe (Remote Procedure Calls)}}
      child { node {System-aufrufe}}
      child { node {Ereignis-management}}
      child { node {IPC Modell}}
      child { node {pop-up-Thread-Modell}}
    };
\end{tikzpicture}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Speichermanagement
\begin{tikzpicture}[ mindmap, grow cyclic, every node/.style=concept, concept color=orange!40,
    level 1/.append style={level distance=4cm},
    level 2/.append style={level distance=3cm, sibling angle=30},
    every node/.append style={scale=0.8}]
  \node{Speichermanagement}
  child { node {Speichertechnologien }}
  child { node {Speicherklassen}}
  child { node {Relokation}}
  child { node {Swapping}}
  child { node {Virtueller Speicher}
      child { node {Virtuelles Speichermanagement}}
      child { node {Begriffe}}
      child { node {Abbildung}}
      child { node {Memory Management Units}}
      child { node {Seiten-abbildungs-tabellen}}
      child { node {Seitenaustausch-Algorithmen}
          child { node {FIFO}}
          child { node {Second Chance}}
          child { node {Least Recently Used}}
          child { node {Working Set}}
          child { node {WSClock}}
        }
    }
  child { node {Segmentierung}}
  ;
\end{tikzpicture}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Dateisystem
\begin{tikzpicture}[ mindmap, grow cyclic, every node/.style=concept, concept color=lime!40,
    level 1/.append style={level distance=4cm},
    level 2/.append style={level distance=3cm, sibling angle=30},
    every node/.append style={scale=0.8}]
  \node{Dateisystem}
  child { node {Dateimodelle}
      child { node {Abstraktion Datei}}
      child { node {symbolischer Namen}}
      child { node {Datei-Attribute}}
      child { node {Operationen auf Dateien}}
    }
  child { node {Dateisysteme}
      child { node {Speichermedien}}
      child { node {Management-Datenstrukturen}
          child { node {Verzeichnisse}}
          child { node {Freiliste}}
          child { node {Superblock}}
        }
    }
  child { node {Datenstrukturen u. Algorithmen}}
  ;
\end{tikzpicture}


\end{document}