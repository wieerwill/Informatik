\documentclass[landscape]{article}
\usepackage[ngerman]{babel}
\usepackage{multicol}
\usepackage{calc}
\usepackage{ifthen}
\usepackage[landscape,left=1cm,top=1cm,right=1cm,nohead,nofoot]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb}
\usepackage{color,graphicx,overpic}
\usepackage{hyperref}
\usepackage{listings}
\usepackage[compact]{titlesec} %less space for headers
\usepackage{mdwlist} %less space for lists

\pdfinfo{
    /Title (Computergrafik - Cheatsheet)
    /Creator (TeX)
    /Producer (pdfTeX 1.40.0)
    /Author (Robert Jeutter)
    /Subject ()
}

% This sets page margins to .5 inch if using letter paper, and to 1cm
% if using A4 paper. (This probably isn't strictly necessary.)
% If using another size paper, use default 1cm margins.
\ifthenelse{\lengthtest { \paperwidth = 11in}}
    { \geometry{top=.5in,left=.5in,right=.5in,bottom=.5in} }
    {\ifthenelse{ \lengthtest{ \paperwidth = 297mm}}
        {\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm} }
        {\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm} }
    }

% Turn off header and footer
\pagestyle{empty}

% Redefine section commands to use less space
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%x
                                {\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
                                {-1explus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%
                                {\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {1ex plus .2ex}%
                                {\normalfont\small\bfseries}}
\makeatother

% Define BibTeX command
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

% Don't print section numbers
\setcounter{secnumdepth}{0}


\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}    
% compress space
\setlength\abovedisplayskip{0pt}
\setlength{\parskip}{0pt}
\setlength{\parsep}{0pt}
\setlength{\topskip}{0pt}
\setlength{\topsep}{0pt}
\setlength{\partopsep}{0pt}
\linespread{0.5}
\titlespacing{\section}{0pt}{*0}{*0}
\titlespacing{\subsection}{0pt}{*0}{*0}
\titlespacing{\subsubsection}{0pt}{*0}{*0}

%My Environments
\newtheorem{example}[section]{Example}
% -----------------------------------------------------------------------

\begin{document}
\raggedright
\scriptsize
\begin{multicols}{3}
  
  
  % multicol parameters
  % These lengths are set only within the two main columns
  %\setlength{\columnseprule}{0.25pt}
  \setlength{\premulticols}{1pt}
  \setlength{\postmulticols}{1pt}
  \setlength{\multicolsep}{1pt}
  \setlength{\columnsep}{2pt}
  
  \section{Mathematik}
  \begin{itemize*}
    \item Vektor $\vec{x}=(x_1,x_2,...,x_n)$
    \item Multiplikation $\alpha * \vec{x} = (\alpha *x_1, \alpha *x_2,...)$
    \item Addition $\vec{x}+\vec{r}=(x_1+r_1, x_2+r_2,...)$
    \item Linearkombination $\vec{o} = (\alpha * \vec{p})+(\beta *\vec{q})+(\gamma * \vec{r})$
    \item Länge: $\vec{p}=(x,y,z): |\vec{p}|=\sqrt{x^2+y^2+z^2}$
    \item Skalarprodukt $\vec{x}*\vec{r}=\sum_{i=0}^{n-1} x_i*r_i$
    \item Winkel $\vec{a}*\vec{b}=|\vec{a}|*|\vec{b}|*cos(\phi)$ mit $cos(\phi)=\frac{\vec{a}*\vec{b}}{|\vec{a}|*|\vec{b}|}$
    \item Vektorprodukt $\vec{a}\times\vec{b} = \begin{pmatrix} a_y b_z - a_z b_y \\ a_z b_x - a_x b_z \\ a_x b_y - a_y b_x \end{pmatrix}$
    \item Ebenen $p=\vec{q}+\alpha*\vec{r}+\beta * \vec{s}$
    \item Dreieck $\vec{A}+\alpha*(B-A)+\beta*(C-A)$
  \end{itemize*}
  
  \subsection{2D Transformation}
  \begin{description}
    \item[Translation] um den Vektor $\vec{t}$
    \item[Skalierung] Stauchung oder Streckung
    \item[Spiegelung]
          \begin{itemize*}
            \item an x-Achse $S=\begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}$
            \item an y-Achse $S=\begin{pmatrix} -1 & 0 \\ 0 & 1 \end{pmatrix}$
            \item am Ursprung $S=\begin{pmatrix} -1 & 0 \\ 0 & -1 \end{pmatrix}$
          \end{itemize*}
    \item[Scherung] $S=\begin{pmatrix} 1 & S_x \\ S_y & 1 \end{pmatrix}$
    \item[Rotation mit Polarkoordinaten] $P'=(r,\phi+\theta)$; $\binom{x'}{y'}=\begin{pmatrix} cos(\theta) & -sin(\theta) \\ sin(\theta) & cos(\theta)\end{pmatrix}*\binom{x}{y}$
    \item[Koordinatentransformation] $$P' =T*P = \begin{pmatrix} x_x & x_y\\ y_x & y_y \end{pmatrix} * \binom{P_x}{P_y}$$
  \end{description}
  
  \paragraph{Homogene Vektorräume}
  kartesischer Vektor $(\frac{x}{w},\frac{y}{w})$ oft $w=1$ gewählt (1=Punkt, 0=Richtung)
  
  \begin{description}
    \item[Skalierung, Projektion, Spiegelung] $\begin{pmatrix} F_x & 0 & 0 \\ 0 & F_y & 0 \\ 0 & 0 & 1 \end{pmatrix} * \begin{pmatrix} x \\ y \\ 1 \end{pmatrix} = \begin{pmatrix} F_x*x \\ F_y*y \\ 1 \end{pmatrix}$
          
          $F_x,F_y>0$, uniform bei $F_X=F_y$
          
          $F_x=0$/$F_y=0$:Projektion auf y/x-Achse 
          
          $F_x=-1$/$F_y=-1$ Spiegelung an y/x-Achse
          
          $F_x=F_y=-1$Spiegelung am Ursprung
          
    \item[Scherung] $\begin{pmatrix} 1 & a & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{pmatrix} * \begin{pmatrix} x \\ y \\ w \end{pmatrix} = \begin{pmatrix} x+a*y \\ y \\ w \end{pmatrix}$
    \item[Rotation] $R_\theta *P= \begin{pmatrix}cos(\theta) & -sin(\theta) & 0 \\ sin(\theta) & cos(\theta) & 0 \\ 0 & 0 & 1 \end{pmatrix} * \begin{pmatrix}x & y & 1 \end{pmatrix} = \begin{pmatrix} x cos(\theta) - y sind(\theta)\\ x sin(\theta)+y cos(\theta)\\ 1 \end{pmatrix}$
  \end{description}
  
  \paragraph{Invertierung}
  \begin{description}
    \item[Transformation]  $T_{\Delta x, \Delta y}^{-1} = T_{-\Delta x, -\Delta y}$
    \item[Skalierung] $S_{F_x, F_y}^{-1}=S_{\frac{1}{F_x},\frac{1}{F_y}}=\begin{pmatrix} \frac{1}{F_x} &0&0\\ 0&\frac{1}{F_y}&0\\ 0&0&1 \end{pmatrix}$
    \item[Rotation] $R_{-\theta} = \begin{pmatrix} cos(\theta) & sin(\theta) & 0 \\ -sin(\theta) & cos(\theta) & 0 \\ 0 & 0 & 1 \end{pmatrix} = R_{\theta}^{T}$
    \item[Verknüpfungen] $(A*B*C)^{-1}=C^{-1}*B^{-1}*A^{-1}$
  \end{description}
  
  \paragraph{Affine Abbildung}
  $$\begin{pmatrix}a_1 & b_1 & c_1\\a_2 &b_2 & c_2\\ 0&0&1\end{pmatrix}*\begin{pmatrix} x_1\\y_1\\1\end{pmatrix}= \begin{pmatrix}x_1'\\y_1'\\1 \end{pmatrix}$$
  \begin{itemize*}
    \item die letzte Zeile der affinen Matrix bleibt immer 0,0,1
    \item paralleles bleibt bei affinen Abbildungen stets parallel
  \end{itemize*}
  
  \subsection{ Homogene Transformation in 3D}
  $(a,b,c,d)$ wobei $(a,b,c)=(nx,ny,nz)$ und $d$ der Abstand der Ebene zum Ursprung
  \begin{itemize*}
    \item Ebene definiert durch 3 Punkte
    $$\begin{pmatrix}
        x_1 & x_2 & x_3 & 0 \\
        y_1 & y_2 & y_3 & 0 \\ 
        z_1 & z_2 & z_3 & 0 \\
        1   & 1   & 1   & 1
      \end{pmatrix}$$
    \item Translation um Vektor $(\Delta x, \Delta y,\Delta z)$
    $$\begin{pmatrix}
        1 & 0 & 0 & \Delta x \\
        0 & 1 & 0 & \Delta y \\ 
        0 & 0 & 1 & \Delta z \\
        0 & 0 & 0 & 1
      \end{pmatrix}$$
    \item Skalierung um Faktor $F_x,F_y,F_z$
    $$\begin{pmatrix}
        F_y & 0   & 0   & 0 \\
        0   & F_y & 0   & 0 \\ 
        0   & 0   & F_z & 0 \\
        0   & 0   & 0   & 1
      \end{pmatrix}$$
    \item Rotation um z-Achse
    $$\begin{pmatrix}
        cos(\theta) & -sin(\theta) & 0 & 0 \\
        sin(\theta) & \cos(\theta) & 0 & 0 \\ 
        0           & 0            & 1 & 0 \\
        0           & 0            & 0 & 1
      \end{pmatrix}$$
    \item Rotation um die x-Achse
    $$\begin{pmatrix}
        1 & 0           & 0            & 0 \\
        0 & cos(\theta) & -sin(\theta) & 0 \\ 
        0 & sin(\theta) & cos(\theta)  & 0 \\
        0 & 0           & 0            & 1
      \end{pmatrix}$$
    \item Rotation um die y-Achse
    $$\begin{pmatrix}
        cos(\theta)  & 0 & sin(\theta) & 0 \\
        0            & 1 & 0           & 0 \\ 
        -sin(\theta) & 0 & cos(\theta) & 0 \\
        0            & 0 & 0           & 1
      \end{pmatrix}$$
  \end{itemize*}
  
  \paragraph{Kameratransformation}
  Kamera ist definiert durch
  \begin{itemize*}
    \item Lage des Augpunktes E (in Weltkoordinaten)
    \item Blickrichtung D
    \item Oben-Vektor U ("view up vector", senkrecht zu D)
  \end{itemize*}
  
  \subsection{Projektion}
  \paragraph{Orthogonale Projektion}
  \begin{itemize*}
    \item Projektionsebene ist parallel zur XY Ebene
    \item Projektionsrichtung stets parallel zur z-Achse (rechtwinklig zur Projektionsebene)
    \item z Koordinaten werden auf gleichen Wert gesetzten
  \end{itemize*}
  
  \paragraph{Schiefwinklige Parallelprojektion}
  \begin{itemize*}
    \item typische Parallelprojektion mit 2 Parametern
    \item Projektionsebene ist parallel zur XY Ebene
    \item Projektionsrichtung hat zwei Freiheitsgrade und ist typischerweise nicht orthogonal zur Projektionsebene
    \item Projektionsrichtung (Schiefe) ist über 2 Winkel parametrisierbar
    \item Herleitung $P=\begin{pmatrix}
        1 & 0 & -cos(\alpha)*f & 0  \\
        0 & 1 & -sin(\alpha)*f & 0  \\
        0 & 0 & 0              & 0  \\
        0 & 0 & 0              & 1 
      \end{pmatrix}$
    \item es gilt: $x'=x-cos(\alpha)*f*z$ und $y'=y-sin(\alpha)*f*z$
  \end{itemize*}
  
  \paragraph{Zentralperspektive}
  \begin{itemize*}
    \item entspricht einer Lochkamera bzw etwa dem 'einäugigen' Sehen
    \item Augpunkt im Ursprung des Kamerakoordinatensystems
    \item Projektionsfläche ist eine Ebene parallel zu XY Ebene
    \item Eigenschaften
    \begin{itemize*}
      \item perspektivische Verkürzung
      \item parallele Linien des Objekts fluchten oft in einen Fluchtpunkt
    \end{itemize*}
  \end{itemize*}
  $$\begin{pmatrix} d&0&0&0\\ 0&d&0&0 \\ 0&0&0&1 \\ 0&0&1&0 \end{pmatrix} * \begin{pmatrix}x\\y\\z\\1\end{pmatrix} = \begin{pmatrix} d*x\\ d*y\\ 1 \\ z \end{pmatrix} \rightarrow \begin{pmatrix} \frac{d*x}{z} \\ \frac{d*y}{z} \\ \frac{1}{z} \end{pmatrix}$$
  
  \paragraph{Fluchtpunkte}
  \begin{itemize*}
    \item hat ein Modell parallele Kanten oder parallele Striche in Texturen, dann ergibt sich für jede solche Richtung r in der Abbildung ein Fluchtpunkt, auf den diese parallelen Kanten/Striche hinzu zu laufen scheinen
    \item es gibt jedoch Ausnahmen, bei denen Paralleles in der Abbildung Parallel bleibt (z.B. horizontale Kanten bei Schwellen)
    \item Da es beliebig viele Richtungen geben kann, sind auch beliebig viele Fluchtpunkte in einem Bild möglich
    \item Rotationen können Fluchtpunkte ändern, Translationen jedoch nicht
    \item Ermittlung: aus Richtung r und Augpunkt eine Gerade, dann schneidet diese Gerade die Projektionsfläche im Fliuchtpunkt für die Richtung r.
  \end{itemize*}
  
  \newpage
  \section{Modellierung}
  
  \paragraph{Boundary Representation (B-Rep)}
  \begin{itemize*}
    \item Beschreibung durch die begrenzende Oberflächen
    \item Darstellungsform eines Flächen- oder Volumenmodells
    \item sind schnell verarbeitbar
    \item Definition des Ojekts über vef-Graph (vertex, edge, face)
    \begin{itemize*}
      \item Knotenliste: beinhaltet Koordinatenpunkt
      \item Kantenliste: pro Kante zwei Punkte referenziert
      \item Flächenliste: pro Fläche die Reihenfolge der Kanten
    \end{itemize*}
    \item Szene: dreidimensionale Beschreibung von Objekten, Lichtquellen und Materialeigenschaften mit Betrachter
    \item Szenegraph: Gruppierung der Objekte in einer Szene
  \end{itemize*}
  
  \subsection{Rendering}
  Pipeline: Geometrisches Objekt$\rightarrow$ Transformieren$\rightarrow$ Vertex Shader$\rightarrow$ Raster Konvertierung$\rightarrow$ Fragment Shader$\rightarrow$ Ausgabebild
  
  \paragraph{Vertex Shader}
  \begin{itemize*}
    \item verarbeitet alle Eckpunkte (Vertices) mit Shader
    \item ermöglicht eine Beeinflussung der Objektform
    \item Transformation der 3D Position auf 2D Koordinaten
    \item Input: Vertices relevanter Objekte der Szene; gewünschte Transformation
    \item Output: auf Bildschirm projizierte 2D Koordinaten und zugehörige Tiefeninformationen
  \end{itemize*}
  
  \paragraph{Model View Projection}
  \begin{itemize*}
    \item Gegeben
    \begin{itemize*}
      \item Modell als Vertices mit kartesischen 3D Koordinaten und definierten Dreiecken
      \item betrachtende Kamera (3D Position, Ausrichtung)
    \end{itemize*}
    \item Umsetzung
    \begin{enumerate*}
      \item $M=T*R*S$ Transformation von Modellraum in Weltkoordinaten (Model)
      \item $V=T_V^{-1}*R_V^{-1}$ Transformation in Kameraraum (View)
      \item Projektion auf Kamerabildebene und Umrechnung in Bildraum (Projektion)
    \end{enumerate*}
    \item Ergebnis
    \begin{itemize*}
      \item MVP-Matrix $P*V*M=MVP_{Matrix}$
      \item Anwendung der MVP ergibt Bildraumprojektion des Modells $p'_m=P*V*M*p_m$
      \item MVP-Matrix muss nur einmal berechnet werden
    \end{itemize*}
  \end{itemize*}
  
  \subsection{Effiziente geometrische Datenstrukturen}
  \paragraph{Bintree}
  \begin{itemize*}
    \item Suchen und Einfügen in eindimensionale Domänen
    \item logarithmische Komplexität pro Zugriff möglich
    \item Gefahr: lineare Komplexität, wenn nicht balanciert
    \item typisch Teilung in Mitte (bisektion)
    \item Bereiche mit homogenem Inhalt werden nicht unterteilt
    \item Komprimierungseffekt
  \end{itemize*}
  
  \paragraph{Quadtree}
  \begin{itemize*}
    \item eine Fläche wird in vier gleichgroße Quadranten unterteilt
    \item Fläche wird unterteilt bis homogenität
    \item Bsp: Objekte in hierarischische Struktur sortieren
    \item Komprimierung, da nur strukturierte Bereiche unterteilt
  \end{itemize*}
  
  \paragraph{Octree}
  \begin{itemize*}
    \item Objekte in hierarchische Strukturen einsortiert
    \item jeder Knoten hat 0 oder 8 Kindknoten (8 Unterbereiche)
    \item beschleunigte räumliche Suche
    \item Zeitaufwand Tiefe des Baumes $O(\log n)$
  \end{itemize*}
  
  \paragraph{KD Tree}
  \begin{itemize*}
    \item mehrdimensionaler binärer Baum (k-dimensional)
    \item unterteilt z.B. abwechselnd in x-,y-, und z-Richtung
    \item Teilung nicht zwangsläufig mittig $\rightarrow$ an Daten angepasst
    \item jeder neue Punkt teilt den Bereich in dem er einsortiert wird; pro Hierarchiestufe stets wechsel der Teilungsrichtung
    \item ein Octree lässt sich auf einen kd-Baum abbilden, beide Baumarten haben vergleichbare Eigenschaften
    \item Median-Cut Strategie: Teilung in zwei gleichgroße Hälften
    \begin{itemize*}
      \item Baum garantiert balanciert und Tiefe minimal
      \item $O(\log n)$ Verhalten garantiert
      \item Probleme bei lokalen Häufungen (Cluster)
      \item unnötige Unterteilung weit weg (Artefakt)
    \end{itemize*}
    \item Middlecut-Strategie:
    \begin{itemize*}
      \item nicht balanciert
      \item keine Unterteilung weit weg vom Cluster
    \end{itemize*}
    \item Kompromiss Strat.: Mischung zwischen Median und Mitte
  \end{itemize*}
  
  \paragraph{BSP Tree}
  \begin{itemize*}
    \item Verallgemeinerung des kd-Baums
    \item Trennebenen nicht nur achsenparallel
    \item Unterteilung in beliebigen Richtungen, adaptiv an Modellflächen angepasst
    \item Trennebenen die an einer Objektebene anliegen können dennoch weiter weg liegende Objekte schneiden.
    \item führt bei konvexen Polyedern zu entarteten Bäumen
  \end{itemize*}
  
  \paragraph{Hüllkörper Hierarchie}
  \begin{description}
    \item[AABB] (Axia-Aligned-Bounding-Box) sehr einfache Abfrage (nur ein Vergleich $<$ in jeder Koordinatenrichtung, wie bei kd-Baum) einfach zu erstellen (min, max), dafür nicht optimale Packungsdichte bei schräger Lage der Objekte
    \item[OBB] (Oriented Bounding Boxes) passen sich besser der räumlichen Ausrichtungen an, lassen sich auch leicht transformieren (Rotation bei Animation). Jedoch schwieriger zu erstellen (Wahl der Richtung), komplexere Überlappungsberechnung (Transformation, Ebenengleichung). Typischerweise weniger tief, weniger räumliche Abfragen dafür wesentlich mehr Berechnungsaufwand pro Rekursionsstufe.
    \item[KDOP] (k-dim. Discretly Oriented Polytopes) Polyeder mit festen vorgegebenen Richtungen (z.B. 45 Grad). Eigenschaften zwischen AABB und OBB. Bessere Raumausnützung als AABB, weniger Transformationene als OBB.
    \item[BS] (Bounding Spheres) Schnelle 3D Überlappungstest (Abstand der Mittelpunkte $<$ Summe der Radien). Langgezogene Objekte können mit mehreren Hüllkugeln begrenz werden um besseren Füllgrad zu erreichen. BS sind bis auf die Lage der Kugelmittelpunkte invariant gegenüber Rotation (geeignet für Kollisionserkennung bewegter Objekte).
    \item[weitere Anwendungsfälle] Kollisionserkennung in Computeranmiation. Reduktion der potenziellen Kollisionspaare durch räumliche Trennung. Beschleunigung des Echtzeitrenderings großer Datenmengen. Reduktion des Aufwands durch Culling (Weglassen)
  \end{description}
  
  \paragraph{Ray Picking mit KD Baum}
  \begin{itemize*}
    \item Vorverarbeitung von Objekten im kd-Baum $O(n \log n)$
    \item Strahl/Objektschnitt: als rekursive Suche im kd-Baum
    \item $treeIntersect(Punkt,Richtung)$: Findet Schnittpunkt des Strahls mit den im Baum gespeicherten Dreiecken und liefert Beschreibung des nächsten Schnittpunktes bzw. t=unendlich, falls kein Schnittpunkt existiert
    \item $triangleIntersect(node,Punkt,Richtung)$: Findet Schnittpunkt des Strahles mit Menge von Dreiecken in node
    \item $subdivide(node, p, d, t_{min}, t_{max})$: Findet rekursiv den nächstgelegenen Schnittpunkt (kleinstes t) des Strahls (p,d) mit den Dreiecken in oder unterhalb von node im Parameterbereich $t_{min} ...t_{max}$
  \end{itemize*}
  
  \paragraph{Aufwandsabschätzung bzgl Dreiecksanzahl}
  \begin{enumerate*}
    \item (beinahe) konvexes Objekt (max. 2 Schnitte): hat die Komplexität einer räumlichen Punktsuche, also dem Aufwand zur Untersuchung einer Baumzelle (finden + dortige Dreiecke testen) $O(\log n)$
    \item Polygonnebel (viele kleine Dreiecke im Such-Volumen)
    \begin{itemize*}
      \item Annahme: alle Zellen enthalten konstante kleine Anzahl von Dreiecken $\rightarrow$ Aufwand proportional zur Anzahl durchlaufener Baumzellen
      \item Anzahl dieser Zellen ist proportional zur Länge des Strahls durchs Volumen, da der 1. Schnitt sehr wahrscheinlich mitten im Volumen oder gar nicht stattfindet $\rightarrow$ Anzahl ist proportional zur Seitenlänge des Suchvolumens
      \item bei n Dreiecken im Suchvolumen ist die Anzahl t der zu untersuchenden Zellen also ca $t=O(\sqrt{n})$ $\rightarrow$ Suchaufwand pro Strahl folglich $O(\sqrt{n} \log (n))$
    \end{itemize*}
  \end{enumerate*}
  
  \paragraph{Aufwandsabschätzung in fps}
  \begin{itemize*}
    \item Effektiver Zeitauwand für Raytracing (RT)
    \item absoluter Gesamtaufwand zum Raytracing einer Szene ist proportional zur Anzahl der Strahlen
    \item Annahme: 1 Strahl pro Pixel (keine Rekursion), typische Bildgröße sei 1 Mio Pixel, Szene haben mittlere Komplexität (1 Mio Polygone)
    \item rekursives RT (Reflexion, Brechung, Schattenstrahlen etc) entsprechend mehr Strahlen, d.h. weniger Performance
    \item Parallelisierung einfach möglich $\rightarrow$ früher CPU, heute eher GPU
  \end{itemize*}
  
  \paragraph*{Heurisitk zur Unterteilung}
  \begin{itemize*}
    \item Surface Area Heuristic (SAH):
    \begin{itemize*}
      \item Strahl $i$, trifft Zelle $j$ mit Wahrscheinlichkeit $P(i,j)$, zudem sei $n_j$ die Anzahl Dreiecke in Zelle $j$
      \item Aufwand für Raytracing pro Zelle proportional zur Baumtiefe ($O(\log n)$ für balancierte Bäume) sowie Anzahl der dortigen Dreiecke $n_j$; $n_j$ wird nicht als konstant angenommen $\rightarrow$ Gesamtaufwand für Strahl $i$ sei also $\sum(P(i,j)*n_j)$
    \end{itemize*}
    \item Heuristik: große Zellen mit wenigen Dreiecken senken Gesamtaufwand
    \begin{itemize*}
      \item Schätzung: $P(i,j)$ ist proportional zur Oberfläche einer Zelle (auf großer Oberfläche treffen mehr Strahlen auf)
      \item die SAH optimiert auf jeder Teilstufe im Baum das Produkt der Zellgröße mal Anzahl Dreiecke im Teilbaum. Für den kD-Baum gilt bei der Unterteilung des Bereichs D in Richtung k: $D_k = D_{k_{links}} + D_{k_{rechts}}$
    \end{itemize*}
    \item Bei ungleicher Verteilung der Dreiecke enthalten dann große Zellen wenige oder keine Dreiecke und Baum ist nicht balanciert $\rightarrow$ implizite Abtrennung des Clusters vom Rest des Baums (vgl. Middle-Cut-Strategie)
  \end{itemize*}
  
  \paragraph{Behandlung ausgedehnter Objekte}
  \begin{itemize*}
    \item Punkte haben keine Ausdehnung und können an einem eindeutigen Ort im kD-Baum abgelegt sein
    \item Ausgedehnte Objekte können räumlich mehrere Blatt- Zellen überlappen. Diese Objekte müssen dann in mehreren Blattzellen einsortiert werden
  \end{itemize*}
  \begin{enumerate*}
    \item Auftrennung von Objekten, d.h. Objekte müssen an der Zellgrenze aufgeteilt werden. Einsortierung der Teilobjekte in passende Zellen. Geht gut für Dreiecke
    \item Keine Unterscheidung zwischen Blattknoten und inneren Knoten. In diesem Ansatz werden Objekte soweit oben im Baum einsortiert, dass sie keine Zellgrenze schneiden. Nachteil: auch relativ kleine Objekte müssen in große Zellen einsortiert werden, wenn sie deren Unterteilungsgrenze schneiden
    \item Loose Octree: die Zellen des Octrees werden so vergrößert, dass sie mit ihren direkten Nachbarn in jeder Richtung um 50\% überlappen. Objekte, die im einfachen Octree aufgrund ihrer Größe Grenzen schneiden würden, können im Loose Octree in den Zwischenknoten gespeichert werden. Ein Objekt mit Durchmesser bis zu $\frac{D}{2^L}$ kann auf der Ebene L abgelegt werden. Eine Suche im Loose Octree muss daher außer der direkt betroffenen Zelle auch die überlappenden direkten Nachbarn berücksichtigen. Dadurch vergrößert sich der Aufwand einer Suche um einen konstantne Faktor. Beachte: Die asymptotosche Komplexität (O-Notation) ist dadurch nicht beeinflusst.
  \end{enumerate*}
  
  \section{Rastergrafik}
  \subsection{Rasterkonversion grafischer Objekte}
  Algorithmus zum Zeichnen einer Strecke: Endpunktkoordinaten sind nach Projektion in die Bildebene passend auf die Fensterkoordinaten skaliert und auf ganzzahlige Werte (Pixelkoordinaten) gerundet.
  
  \subsection{ Midpoint Algorithmus}
  \begin{itemize*}
    \item Grundidee: Effizient durch Verwendung von Ganzzahlen, Vermeiden von Multiplikation/Division sowie Nutzung einer inkrementellen Arbeitsweise
    \item Die Linie geht zwischen den Endpunkten nicht durch ganzzahlige Gitterpunkte. Da nur ganzzahlige Pixel-Koordinaten gesetzt werden können müssten auch zwischenpunkte zuerst genau berechnet werden und dann auf ganzzahlige Pixelwerte gerundet werden. Dies ist unzuverlässig und ineffizient. Zur Herleitung des effizienten Bresenham-Algorithmus führen wir den Mittelpunkt M als Referenzpunkt ein. Ferner seinen der jeweils aktuellen Punkt P, der rechts von im liegende E (east) und der rechts oben liegende NE (north-east) benannt.
    \item die Linie wird als Funktion repräsentiert: $y=\frac{\delta y}{\delta x}*x+B$
    \item implizierte Form: $d: F(x,y)=\delta y*x-\delta x*y+B*\delta x = 0$
    \item für Punkte auf der Linie wird $F(x,y)=0$
    \item für Punkte unterhalb der Linie wird $F(x,y)>0$
    \item für Punkte oberhalb der Linie wird $F(x,y)<0$
    \item Herleitung mit Einschränkung: Steigung der Linie m ($-1<m<1$), Mittelpunkt M = Punkt vertikal zwischen zwei möglichen Pixeln E und NE. Ausgehend von bereits gesetzten Pixel P auf der Linie für den nächsten Mittelpunkt M. Für gefundenen Mittelpunkt, berechne die Distanzfunktion d. Daraus Kriterium zur Wahl des nächsten Pixels: Falls $F(x_p + 1, y_p+\frac{1}{2})>0$ wird das nächste Pixel NE, andernfalls E.
    \item Insgesamt acht verschiedene Fälle:
    \begin{enumerate*}
      \item Oktant($\delta y < \delta x$)
      \item Oktant($\delta y > \delta x$)
      \item Oktant($\frac{\delta y}{\delta x}<  0$)
      \item Oktant($\frac{\delta y}{\delta x}< -1$)
      \item - 8. Oktant($\delta x < 0$)
    \end{enumerate*}
  \end{itemize*}
  
  \paragraph{Anti Aliasing}
  \begin{itemize*}
    \item Treppenstufeneffekt bei gerasterten Linien
    \item Regelmäßigkeit wird verstärkt vom Auge wahrgenommen
    \item Auflösungsvermögen des Auges für Punkte sei e. Strukturen wie Linien werden durch Mittelwertbildung (Fitting) vom Auge viel genauer als e lokalisiert. Eine Stufe wird umso eher erkannt, je länger die angrenzenden Segmente sind.
    \item Grundidee des Anti-Aliasing
    \begin{itemize*}
      \item Statt der Linie wird ein Rechteck mit der Breite von einem Pixel betrachtet
      \item Graustufen der darunter liegenden Pixelflächen entsprechen dem jeweiligen Überdeckungsgrad
    \end{itemize*}
    \item Praktische vereinfachte/effiziente Umsetzung
    \begin{itemize*}
      \item Rasterkonvertierung der Linie bei doppelter örtlicher Auflösung (Supersampling)
      \item Replizieren der Linie (vertikal und/oder horizontal) um Linienbreite näherungsweise zu erhalten
      \item Bestimmmung des Überdeckungsgrades pro Pixel in der ursprünglichen Auflösung (Downsampling)
      \item Bestimmung des Farbwertes entsprechend des Überdeckungsgrades
    \end{itemize*}
    \item Problem:
    \begin{itemize*}
      \item Ausgabe von Linien/Polygonen auf Rastergeräten muss auf vorgegebenem Raster erfolgen
      \item Farbvariation ist möglich, muss effizient erfolgen
    \end{itemize*}
    \item Ohne Antialiasing:
    \begin{itemize*}
      \item es erfolgt ein einfacher Test über die Pixelkoordinate
      \item verwendet Farbe in der Pixelmitte
    \end{itemize*}
    \item Ideales Antialiasing: Hat wegen der beliebig komplexen Geometrie allgemein einen sehr/zu hohen Aufwand!
    \item Ansatz für eine 'reale Lösung'
    \begin{itemize*}
      \item ideale Berechnung von Farbwerten nach dem Überdeckungsgrad ist praktisch irrelevant
      \item Gesucht werden Ansätze mit gut abschätzbarem/konstanten Aufwand
      \item beruht auf der Verwendung von mehreren Samples pro Pixel, d.h. Berechnung dieser n Samples statt nur einem (typisch: n-facher Aufwand)
    \end{itemize*}
  \end{itemize*}
  
  \paragraph{Supersampling + Downsampling}
  \begin{itemize*}
    \item Grafik zunächst in höherer Auflösung gerendert (z.B. 4-fach) und dann aus den Samples ein Farbwert gemittelt
    \item Ohne Anti-Aliasing kommt pro Pixel genau eine Sampleposition zum Zuge. Das Pixel wird demnach gefärbt oder nicht gefärbt: Das sind zwei mögliche Stufen.
    \item Bei vier Subpixeln können minimal 0 und maximal 4 Subpixel im (Makro-)Pixel gesetzt sein, d.h. es sind 5 Intensitäten von 0\%, 25\%0, 50\%, 75\% oder 100\% möglich
    \item Es gibt immer eine Abstufung mehr als Subpixel pro Pixel
    \item bei Formabhängigkeit gibt es nur eine Zwischenstufe je nach Phasenlage $\rightarrow$ Kante "pumpt" bei Objektbewegung.
  \end{itemize*}
  
  \paragraph{Supersampling + Rotated Grids}
  \begin{itemize*}
    \item minderung der Formabhängigkeit
    \item kleine Winkel führen zu langen Stufen der Polygonkante
    \item bessere Verhältnisse der Grauabstufung für flache Winkel, wenn ordered-grid statt rotated-grid verwendet wird
    \item Rotated grids sind bei anderen Winkeln etwas schlechter als das ordered grid. Wird kaum wahrgenommen
    \item gute Grauabstufung bei sehr flachen Kanten zur Zeilen- oder Spaltenrichtung
    \item optimaler Winkel bei ca. 20-30° z.B. $arctan(0.5) \approx 26,6^{\circ}$
    \item sehr dünne Linien bleiben auch bei Bewegung zusammenhängend/sichtbar (Vermeidung von "Line Popping")
  \end{itemize*}
  
  \paragraph{Supersampling + Multisampling}
  \begin{itemize*}
    \item Realisierung der Subpixelberechnung durch
    \item ein Superbackpuffer (großem Buffer)
    \begin{itemize*}
      \item Nachteil (bei rotated grid): Anpassung der Rasterkonvertierung an verschobene Positionen
      \item Vorteil: Verwendung von mehr Texturinformation (Textur wird subpixelgerecht eingetragen)
    \end{itemize*}
    \item mehrere Multisamplebuffer (mehrere kleinere Buffer)
    \begin{itemize*}
      \item Mehrfachrendering in normaler Größe mit versetzter Geometrie (Vertexverschiebung pro Sub-Bild)
      \item Vorteil: keine Veränderung im Rendering
      \item Nachteil: nur ein Texturwert pro Makro-/Sub-Pixel
    \end{itemize*}
    \item Gezielter Ressourceneinsatz durch Kantenglättung
    \begin{itemize*} 
      \item Effizienzsteigerung durch Beschränkung auf reine Kantenglättung möglich
      \item Anzahl der Kantenpixel oft wesentlich kleiner als Anzahl der Flächenpixel
      \item Aliasing bei Mustern in Texturen schon beim Auslesen der Werte aus Pixeltextur unterdrückbar
      \item Kantenpixel bekannt als separate Linien oder Berandung von Polygonen/Dreiecken
    \end{itemize*}
    \item adaptives Samplen: statt feste Anzahl von Samples kann die Anzahl nach dem Bedarf gesteuert werden
  \end{itemize*}
  
  \paragraph{Quincunx Verfahren}
  \begin{itemize*}
    \item Überfilterung
    \item 2x Multisampling mit rotated grid; Informations- zuwachs ist durch doppelte Anzahl von Samples gekennzeichnet
    \item Information für die Kantenglättung beruht auf 2 Subpixeln
    \item Entspricht einer zusätzlichen Tiefpass-Überfilterung. Durch die Unschärfe sehen Polygonkanten glatter aus.
    \item Harte Kanten sind gar nicht mehr möglich, dadurch wird auch 'Zappeln' an Polygonrändern reduziert
    \item Nachteil: Texturinformation, die nur zu 2 Subpixeln gehört, wird verschmiert
  \end{itemize*}
  
  \paragraph{Pseudozufälliges Supersampling}
  \begin{itemize*}
    \item Kombinationen und pseudozufälliges Supersampling
    \begin{itemize*}
      \item Kombination von Supersampling, Multisampling und Quincunx möglich; Gewinn hält sich in Grenzflächen
      \item Bei Überwindung der Grenzen für Füllrate und Bandbreite überwiegen die Vorteile des Supersamplings.
      \item Ordered grid und rotated grid weisen bei bestimmten Strukturklassen Vor- und Nachteile auf. Die verbleibenden Artefakte wiederholen sich bei großen Flächen so, dass derartige Muster vom Menschen oft als störend empfunden werden
      \item pseudozufällige Auswahl von Abtastmustern für das Supersampling
      \item nachträgliche Abminderung regelmäßiger Strukturen durch vorsichtiges Verrauschen (Rauschfilter)
      \item entfernungsabhängiges Antialiasing
    \end{itemize*}
    \item pseudozufällig
    \begin{itemize*}
      \item Samples können nur an n vordefinierten Positionen stattfinden (Sample-Positionsmuster)
      \item Je nach Methode werden daraus m Positionen für das Samplen zufällig ausgewählt (beachte: $m < n$)
      \item Anzahl der Muster als kombinatorisches Problem: m aus n (ohne Wiederholungen)
    \end{itemize*}
  \end{itemize*}
  
  \paragraph{Downsampling}
  Beim Anti-Aliasing zur Glättung von Polygonkanten kommt für das Downsampling die Mittelwertbildung in Frage (lineare Filterung (2x - AA), bilineare Filterung (4x - AA)), gleichgültig ob ordered oder rotated grid. Beim pseudozufälligen Supersampling ist entsprechend der "frei gewählten" Positionen der "Subpixel" zu modifizieren (z.B. Gewichte nach Abstand der Abfragepositionen zur Makropixelposition).
  
  \subsection{ Polygonfüllalgorithmus}
  \begin{itemize*}
    \item Ansatz
    \begin{itemize*}
      \item finde die Pixel innerhalb des Polygons
      \item weise ihnen Farbe zu
      \item dabei zeilenweises Vorgehen pro Rasterlinie
      \item für jede Polygonkante: schneide die Polygonkante mit der aktuellen Bildzeile ($\rightarrow x_s$ )
      \item füge Schnittpunkt $x_s$ in eine Liste ein
      \item sortiere Schnittpunkte der Bildzeile in x-Richtung
      \item Paritätsregel: fülle die Pixel jeweils nur zwischen ungeraden und nächstem geraden Schnittpunkt
    \end{itemize*}
    \item Schnittpunkte in floating point zu berechnen und zu runden ist ineffizient. Ähnlich wie beim Bresenham-Algorithmus, inkrementeller Ansatz mit Ganzzahl-Arithmetik
    \item Allgemeine Sicht auf die Füll-/Auswahlstrategie: Ein Pixel wird mit der Farbe des Polygons gefüllt, das sich rechts von ihm befindet. Sollte dort eine Kante sein, so wird die Farbe des oberen Polygons verwendet.
    \item Grundsätzlich könnten beliebige Richtungen als Referenzrichtung zur Farbbestimmung gewählt werden. Dann müssten die zuvor besprochenen Regeln oder der gesamte Algorithmus entsprechend angepasst werden.
    \item Effiziente Ermittlung der Schnittpunkte von Polygonkante und Rasterzeile:
    \begin{itemize*}
      \item Polygonkanten von unten nach oben bearbeitet
      \item horizontale Polygonkanten müssen nicht bearbeitet werden $\rightarrow$ $m\not=0$
      \item $d_y = y_1 - y_0$ ist stets positiv (auch nie 0)
      \item $d_x = x_1 - x_0$ kann positiv und negativ sein
      \item damit können 4 Bereiche unterschieden werden
      \item Berechnung von x bzw y: 
      \begin{itemize*}
        \item $y=y_0+m(x-x_0)= y_0+\frac{y_1-y_0}{x_1-x_0}(x-x_0)$,
        \item$x=x_0+\frac{1}{m}(y-y_0)= x_0+\frac{x_1-x_0}{y_1-y_0}(y-y_0)$
      \end{itemize*}
      \item x-/y-Werte noch nicht ganzzahlig, aber können als rationale Zahlen explizit mit Zähler und Nenner repräsentiert werden
      \item Die Rundung (nächstes x oder y erreicht?) kann inkrementell ermittelt werden
      \item Die Rundungsregel für Bruchwerte hängt davon ab, ob es eine linke oder rechte Kante ist. Links wird z.B. aufgerundet (Pixel ist auf oder rechts v. der Kante)
    \end{itemize*}
    \item Edge-Tabelle:
    \begin{itemize*}
      \item  Verkettete Liste/Array für nicht-horizontalen Kanten
      \item  Sortierung nach der Scan-Line, wo die Kanten beginnen (unteres Ende, $y_0$ ).
      \item  Innerhalb der Scan-Line wieder Liste (nach $x_0$ sortiert). Je nach Implementierung werden z.B. $x_0 , y_1$ , sowie Zähler und Nenner gespeichert.
    \end{itemize*}
    \item Active-Edge-Tabelle:
    \begin{itemize*}
      \item  speichert alle Kanten, die gegenwärtige Scan-Linie schneiden
      \item  Liste hat die gleiche Struktur wie eine Zeile der ET
      \item  Kanten gelöscht, wenn oberes Ende der Kante erreicht ist
    \end{itemize*}
    \item Bemerkung zu Scan Convert Polygon: Es existiert immer eine gerade Anzahl Kanten. Bei konvexen Polygonen sind immer null oder zwei Kanten in der AET. Die Sortierung ist dadurch trivial bzw. entfällt bei konvexen Polygonen. Bei vielen Grafikbibliotheken beschränkt man sich auf konvexe Polygone. Nichtkonvexe Polygone müssen daher vorher in konvexe Komponenten zerlegt werden. Dafür ist das Füllen dieser Polygone danach effizienter. Dieser Teil entspricht einem Schleifendurchlauf der Prozedur EdgeScan. Die Unterscheidung zwischen linker und rechter Kante wird beim Auffüllen der Pixel gemacht.
    \item Bemerkungen zur Effizienz
    \begin{itemize*}
      \item Ein Polygon belegt meist mehr Pixel als es Eckpunkte/Kanten besitzt. Deshalb sind effiziente per-Pixel-Operationen wichtig. Der Rechenaufwand sollte vermieden werden (fallende Priorität) für:
      \item  pro Pixel (sehr häufig auszuführen)
      \item  pro Rasterzeile
      \item  pro Kante (möglichst viel vorberechnen, um pro Rasterzeile/Pixel Rechenzeit zu sparen)
    \end{itemize*}
      \item Erweiterungen des inkrementellen Ansatzes für effiziente Berechnungen in der 3D-Grafik, z.B.:
      \item Füllen des Z-Buffers (Tiefenwertberechnung)
      \item lineare Interpolation beim Gouraud Shading (Farbwertberechnungen)
  \end{itemize*}
  
  \paragraph{Füllmuster}
  \begin{itemize*}
    \item Füllen eines Polygons mit Pattern statt konstanten Farbwert
    \item benutze dazu BITMAPs
    \item 2-dimensionales Array
    \item besteht aus M Spalten und N Zeilen
    \item $BITMAP = ARRAY [0... (M-1), 0...(N-1)]$
  \end{itemize*}
  
  \paragraph{Dithering}
  \begin{itemize*}
    \item Ersetzen 'genauer' Farbwerte durch grobe Quantisierung
    \item gegeben sei Tabelle von im Output zulässigen Farben
    \item Durchlaufen aller Pixel beginnend links oben
    \item pro Pixel P die beste Ersetzung in Tabelle finden \& setzen
    \item verursachten Fehler $\delta$ jeweils nach Schema auf unbearbeitete Nachbarpixel in der  Repräsentation verteilen
    \item bei kleinen Bildern mit hoher Auflösung ist Dithering kaum wahrnehmbar
  \end{itemize*}

  \paragraph{Dithering vs. Anti-Aliasing}
  \begin{itemize*}
    \item komplementär zueinander
    \item A.A. erhöht empfundene räumlich Auflösung durch Anwendung von Zwischenwerten in der Grau-/Farbabstufung
    \item Dithering erhöht Farbauflösung (verringert empfundene Farbquantisierung) durch Verteilen des Quantisierungsfehlers auf mehrere Pixel $\rightarrow$ Verringerung der räumlichen Auflösung
  \end{itemize*}
  
  \section{Farbräume}
  \subsection{ Farbwahrnehmung - Phänonmenologie}
  \begin{itemize*}
    \item Hell- und Farbempfinden als Sinneseindruck beschrieben
    \item Tageslicht als weiß/grau mit unterschiedlichen Helligkeiten aber farblos empfunden
    \item Abwesenheit von Licht wird als schwarz empfunden
    \item Regenbogen bunt mit verschiedenen Farbtönen empfunden
  \end{itemize*}
  \begin{description}
    \item[Farbton (Hue)]
          \begin{itemize*}
            \item Farbpalette aus abstufung grober Farbtöne 
            \item direkt nebeneinanderliegende Farben im Farbspektrum werden als ähnlich empfunden
            \item Farbwerte lassen sich ordnen
            \item als bunt empfunden (voll gesättigte Farben im Gegensatz zu Grautönen)
          \end{itemize*}
    \item[Farbsättigung (Saturation)]
          \begin{itemize*}
            \item  Stufen zwischen Bunt und Grau
            \item Pastelltöne sind weniger bunt aber nicht farblos
            \item Grauton (keine Farbwerte unterscheidbar)
            \item jedem Farbton können Abstufungen bis Grau zugeordnet werden
          \end{itemize*}
    \item[Helligkeitsstufen (Lightness)]
          \begin{itemize*}
            \item unterschiedliche Helligkeitsabstufungen bis Schwarz
            \item im Schwarzen sind keine Farbtöne mehr unterscheidbar
          \end{itemize*}
  \end{description}
  
  \subsection{Modell der Farben}
  \paragraph{HSL Farbraum (bzw HSB, HSV, HSI)}
  \begin{itemize*}
    \item Farbton: Hue
    \item Sättigung: Saturation
    \item Helligkeit: Lightness/Brightness/Value/Intensity
    \item Dimension des Farbtons wiederholt sich periodisch
    \item darstellung als Winkelkoordinate eines Polarkoordinaten-Systems in der HS-Ebene oder dreidimensional als Zylinderkoordinaten HSL darstellt.
    \item Darstellungsformen nicht fest vorgeschrieben. Eine Darstellung als (Doppel)-Kegel oder sechseitige (Doppel-) Pyramide ist ebenso möglich
    \item Der HSL Farbraum entspricht grob unserer Farbwahrnehmung. Daher geeignet zur intuitiven und qualitativen Einstellung von Farben in Illustrationsgrafiken
    \item Relative Skala 0-255
    \item Quantisierbarkeit der Farben und Helligkeit
    \item Bezug zur Physik des Lichtes (Energie, Spektrum)
  \end{itemize*}

  \paragraph{RGB Farbraum}
  \begin{itemize*}
    \item Hypothese, dass Farbsehen auf drei Arten von Sinneszellen beruht (rot, grün, blau) (Young)
    \item Farbwahrnehmungen durch drei beliebige, linear unabhängige Größen darstellbar (Graßmann)
    \item Mit Grundfarben Rot, Grün und Blau können weitere Farben additiv gemischt werden
    \item Bestimmen der Anteile der Mischfarben
    \begin{itemize*}
      \item Empfindlichkeitskurven R,G,B und zugehörige Lichtquellen r,g,b
      \item alle 3 Lichtquellen zusammen ergeben weis wahrgenommenes Licht: $r=g=b=1$
      \item damit 3d-Farbraum (RGB-Farbraum) aufspannen
      \item Lage einer monochromatischen Lichtwelle: $x(\lambda_0)=p*r+\gamma*g+\beta*b$
      \item Achtung: hängt von Wellenlängen der verwendeten Grundfarben r,g,b (Primärvalenzen) ab.
    \end{itemize*}
    \item Beispiel für Reizung durch monochromatisches Licht (Laser):
    \begin{itemize*}
      \item $r=0,2R(\lambda)$
      \item $y=0,5R(\lambda)+0,3G(\lambda)$
      \item $g=0,2R(\lambda)+0,5G(\lambda)$
      \item $b=0,02B(\lambda)$
    \end{itemize*}
    \item Intensität: $I=\frac{R+G+B}{3}$
    \item Innere Farbmischung: mischen direkt aus Grundfarben
    \item Äußere Farbmischung: hinzufügen von Grundfarben zu bestehender Mischung
  \end{itemize*}
  
  Farberzeugung durch Mischung:
  $$1,9r + 0,6g = 0,38R(\lambda)+0,12R(\lambda)+0,3G(\lambda)=0,5R(\lambda)+0,3G(\lambda) = y$$
  
  Idee:
  \begin{itemize*}
    \item drei linear-unabhängige Größen benötigt, zur Beschreibung und (technischen) Reproduktion der Farbempfindung
    \item zunächst werden folgende Werte gewertet
    \begin{itemize*}
    \item die additive Mischung als Reproduktionsmethode
    \item drei Primärfarben Rot, Grün, Blau
    \item drei linear unabhängige Größen spannen stets einen 3D Raum auf
    \end{itemize*}
    \item die RGB Werte werden den drei ortogonalen Achsen dieses Raumes zugeordnet
  \end{itemize*}
  
  Darstellung des RGB Farbraums:
  \begin{itemize*}
    \item alle technisch/additiv erzeugbaren Farben liegen innerhalb eines Würfels
    \item Im Koordinatenursprung befindet sich Schwarz
    \item auf der Raumdiagonalen liegen dazwischen die Graustufen
  \end{itemize*}
  
  RGB Farbtafel:\\
  Alle Farben gleicher Buntheit führen zum gleichen Farbort, der durch die Farbwertanteile r,g,b beschrieben wird:
  $$r=\frac{R}{R+G+B}, g=\frac{G}{R+G+B}, b=\frac{B}{R+G+B} \leftrightarrow r+g+b=1$$
  
  Aus dem rechten Teil der Gleichung folgt mit $b=1-r-g$, dass sich die Buntheit allein durch r und g darstellen lässt (entspricht $R^2$).  
  
  \paragraph{CIE System}
  Um eine Relation zwischen der menschlichen Farbwahrnehmung und den physikalischen Ursachen des Farbreizes herzustellen, wurde das CIE-Normvalenzsystem definiert. Es stellt die Gesammtheit der wahrnehmbaren Farben dar.
  
  \paragraph{Farbkörperunterschiede}
  Es finden sich Unterschiede welche Farbbereiche nach dem CIE Normalvalenzsystem von den jeweiligen Systemen dargestellt werden können:
  \begin{itemize*}
    \item menschliche Farbwahrnehmung ca. 2-6 Mio Farben
    \item Monitor ca. 1/3 davon. Bei Monitoren wird die additive Farbmischung verwendet, da die einzelnen Lichtquellen aufsummiert werden.
    \item Druckprozess deutlich weniger Farben. Es werden einzelne Farbschichten auf Papier gedruckt und das resultierende Bild wird über subtraktive Farbmischung bestimmt
  \end{itemize*}
  
  \paragraph{Subtraktive Farbmischung}
  Je nachdem welche Farbe ein Material hat, werden entsprechende Farbanteile absorbiert oder reflektiert. Eine gelbe Oberfläche sieht gelb aus, da sie das Blau aus weißem Licht absorbiert, aber Rot und Grün reflektiert.
  
  Achtung: Dies gilt nur für die Bestrahlung mit weißem Licht. Wird beispielsweise ein gelbes Blatt mit blauem Licht bestrahlt, dann wirkt es schwarz, da das blaue Licht vom gelben Blatt absorbiert wird.
  
  \section{Licht \& Reflexion}
  \subsection{ Strahlung}
  Grundfrage: Was ist Licht?
  \begin{itemize*}
    \item Teil der elektromagnetischen Strahlung
    \item ist für das menschliche Auge wahrnehmbar
    \item Lichtspektrum liegen zwischen 380 nm und 780 nm
    \item Farbe entspricht der Wellenlänge
    \item längere Wellenlängen = weniger Photonenenergie
    \item durch Überlagerungen vieler Frequenzen erscheint das Licht weiß
  \end{itemize*}
  
  Radiometrie:
  \begin{itemize*}
    \item Wissenschaft von der Messung elektromagnetischer Strahlung
    \item Größen sind physikalische Einheiten (ohne Berücksichtigung des menschl. Sehens)
  \end{itemize*}
  
  Photometrie:
  \begin{itemize*}
    \item Messverfahren im Wellenlängenbereich des sichtbaren Lichtes (Messung mithilfe eines Photometers)
    \item lassen sich aus den radiometrischen Größen, bei bekanntem Spektrum bestimmen
    \item berücksichtigen die wellenlängenabhängige Empfindlichkeit des Auges
  \end{itemize*}
  
  Photon:
  \begin{itemize*}
    \item Elementarteilchen der elektromagnetischen Wechselwirkung
    \item besitzen keine Masse
    \item Energie und Impuls sind proportional zur Frequenz
    \item kürzere Wellenlänge = höhere Frequenz = höhere Energie
  \end{itemize*}
  
  Strahlungsenergie (radiant energy):
  \begin{itemize*}
    \item durch Strahlung (elektromagnetische Wellen) übertragene Energie
    \item entspricht dem Produkt von Photonenanzahl und der Energie der Photonen
    \item Formelzeichen : Q
    \item Einheit: J (Joule)
    \item photometrisches Äquivalent: Lichtmenge (luminous energy)
  \end{itemize*}
  
  Strahlungsleistung (auch Strahlungsfluss, engl. radiant flux, radiant power):
  \begin{itemize*}
    \item transportierte Strahlungsenergie in einer bestimmten Zeit
    \item Formelzeichen : $\phi$
    \item Einheit: W (Watt)
    \item Berechnung: $\phi = \frac{Q}{t}$
    \item photometrisches Äquivalent: Lichtstrom (luminous flux, luminous power)
  \end{itemize*}
  
  Zusammenhang zwischen Radiometrie und Photometrie:\\
  In der Radiometrie wird sich mit objektiven Messgrößen beschäftigt, in der Photometrie gibt es jeweils eine entsprechende Messgrößen, bei denen die spektrale Empfindlichkeit des menschlichen Auges mit einfließt.
  \begin{itemize*}
    \item Beispiel:
    \item radiometrisch: Strahlungsleistung $\phi_e$ gemessen in Watt W
    \item photometrisch: Lichtstrom $\phi_v$ gemessen in Lumen lm
    \item Verknüpfung von Radiometrie und Photometrie erfolgt über das photometrische Strahlungsäquivalent: $K =\frac{\phi_v}{\phi_e}$
    \item gibt die Empfindlichkeit des menschlichen Auges an
    \item radiometrische Größe: Index $_e$ für energetisch
    \item photometrische Größe: Index $_v$ für visuell
  \end{itemize*}
  Die radiometrischen Größen gewichtet mit dem photometrischen Strahlungsäquivalent K sind somit die photometrischen Größen.
  
  Ausbreitung eines Strahls:
  \begin{itemize*}
    \item geradlinig von einer Quelle zum Ziel,
    \item Richtung ändert sich durch Brechung
    \item an Oberflächen tritt Reflexion und Streuung auf
    \item eine Strahlungsquelle sendet dabei Strahlen in alle Raumrichtungen unter einem gewissen Raumwinkel aus
  \end{itemize*}
  
  \paragraph{Raumwinkel}
  Der Steradiant ist eine Maßeinheit für den Raumwinkel, der von der Mitte M einer Kugel mit Radius r aus gesehen eine Fläche von $r^2$ auf der Kugeloberfläche einnimmt. $\Omega=\frac{Flaeche}{Radius^2}=\frac{A}{r^2}sr$
  Eine komplette Kugeloberfläche $A_k$ beträgt allg. $A_k = 4\pi r^2$, entspricht also einem Raumwinkel $\Omega$ von $\frac{A_k}{r^2}= 4\pi r\approx 12,5sr$. Ein Steradiant =1sr entspricht einem Öffnungswinkel $\alpha$ von ca. $65,54^{\circ}$
  
  \paragraph{Strahlstärke}
  \begin{itemize*}
    \item auch Intensität, engl. radiant intensity
    \item Strahlungsleistung die in eine Raumrichtung mit Raumwinkel $\Omega$ emittiert wird
    \item Formelzeichen : I
    \item Berechnung: $I=\frac{\phi}{\Omega}$
    \item photometrisches Äquivalent: Lichtstärke (luminous intensity)
  \end{itemize*}
  
  Beispiel: Berechnen Sie die Strahlstärke einer Lampe mit einem Öffnungswinkel von 180° und einer Strahlungsleistung von 20W.
  $$\alpha=180^{\circ}\rightarrow A=2\pi r^2; \phi =20W; \Omega=\frac{A}{r^2}=2\pi ; I_e=\frac{\phi_e}{\Omega}=\frac{20}{2\pi}\approx 3,2 \frac{W}{sr}$$
  
  \paragraph{Räumliche Ausbreitung}
  Energieübertragung zwischen zwei Flächen:
  Eine Fläche $A_r$ strahlt Licht auf eine Fläche $A_i$ ab.\\
  Frage: Wie viel Lichtleistung von einer infinitesimalen abstrahlenden Fläche $A_r$ wird auf einer Fläche $A_i$ empfangen?
  \begin{itemize*}
    \item der Abstand zwischen den beiden infinitesimalen Flächen beträgt r
    \item die Flächen stehen nicht notwendigerweise senkrecht zur Ausbreitungsrichtung des Lichts (gerade Verbindungslinie zwischen den Flächen)
    \item Wir projizieren daher die abstrahlende und die empfangende Fläche jeweils in Ausbreitungsrichtung. Die projizierten Flächen nennen wir $A'_r$ und $A'_i$.
    \item Wir betrachten Punktlichtquellen von der abstrahlenden Fläche $A_r$ , welche ihre Strahlungsleistung in den Raumwinkel $\Omega$ abgeben.
    \item $\Omega$ ist somit die in Abstrahlrichtung reduzierte Fläche $A'_i$ , projiziert auf die Einheitskugel: $\Omega=\frac{A'_i}{r^2}$
    \item Die übertragene Energie nimmt quadratisch zu r ab
  \end{itemize*}
  
  \paragraph{Strahldichte}
  \begin{itemize*}
    \item engl. radiance
    \item Strahlstärke welche von einer Sendefläche $A_r$ in eine bestimmte Richtung abgegeben wird
    \item Formelzeichen : L
    \item photometrisches Äquivalent: Leuchtdichte (auch Luminanz, engl. luminance)
    \item Berechnung: $L = \frac{I}{A'_r}=\frac{I}{\cos(\phi_r)*A_r} = \frac{\phi}{\cos(\phi_r)*A_r*\Omega}$
    \item $\phi_r$ ist der Winkel zwischen der Normalen n und der Abstrahlrichtung (von der abstrahlenden Fläche $A_r$ zur empfangenden $A_i$)
  \end{itemize*}
  
  Leuchtdichte (Luminanz) als Vorstufe der Helligkeit:
  \begin{itemize*}
    \item Strahlungsleistung bewertet mit der spektralen Empfindlichkeitsfunktion des menschlichen Auges für das Hellempfinden
    \item Das menschliche Auge hat seine maximale Empfindlichkeit, bei einer Wellenlänge von 555 nm (gelbgrün)
    \item 1 Lumen ist definiert als der Lichtstrom einer 1,464 mW starken 555-nm-Lichtquelle mit 100% Lichtausbeute.
  \end{itemize*}
  
  
  \paragraph{Bestrahlungsstärke}
  \begin{itemize*}
    \item auch Strahlungsflussdichte, engl. irradiance
    \item Strahlungsleistung durch die bestrahlte Fläche $A_i$ bzw. Strahlstärke die auf die Empfängerfläche trifft
    \item Formelzeichen : E
    \item Berechnung: $E =\frac{\Phi}{A_i}$
    \item photometrisches Äquivalent: Beleuchtungsstärke (auch Lichtstromdichte, engl. illuminance)
    \item erweitert: $E=\frac{\Phi}{A_i}=\frac{L*\cos(\phi_i)*\cos(\phi_r)*A_r}{r^2}$
  \end{itemize*}
  
  \paragraph{Zusammenfassung}
  Radiometrische (physikalische) und Photometrische (unter Berücksichtigung des menschlichen Auges) Größen
  
  \begin{tabular}{ c | c | c }
    Symbol & Radiometrie (energetisch $_e$)     & Photometrie (visuell $_v$ )             \\ \hline
    $Q$    & Strahlungsenergie $Joule$          & Lichtmenge $lm*s$                       \\
    $\Phi$ & Strahlungsleistung Watt $W$        & Lichtstrom Lumen $lm$                   \\
    $I$    & Strahlstärke $\frac{w}{sr}$        & Lichtstärke Candela $cd$                \\
    $E$    & Bestrahlungsstärke $\frac{W}{m^2}$ & Beleuchtungsstärke Lux $\frac{lm}{m^2}$ \\
    $L$    & Strahldichte $\frac{w}{sr*m^2}$    & Leuchtdichte $\frac{cd}{m^2}$           \\
  \end{tabular}
  
  
  \subsection{ Reflexion}
  Nach dem Auftreffen auf einer opaken Oberfläche wird die Strahlung spektral
  unterschiedlich stark und geometrisch auf unterschiedliche Weise reflektiert. Es
  können 2 Idealfälle der Reflexion unterschieden werden:
  \begin{itemize*}
    \item ideal spiegelnde Reflexion (Einfallswinkel = Ausfallswinkel)
    \item ideal diffuse Reflexion
  \end{itemize*}
  
  Aus den zwei Idealfällen der reflexion werden weitere (gemischte) Fälle abgeleitet:
  \begin{itemize*}
    \item spekuläre Reflexion (diffus und gerichtete Reflexion)
    \item gemischte Reflexion: ideal diffus, gerichtet diffus und ideal spiegelnd
  \end{itemize*}
  
  Bei der Betrachtung der Reflexion ist offensichtlich die Art der Bestrahlung und
  insbesondere auch die Richtung der Einstrahlung zu beachten.
  
  \paragraph{Diffuse Reflexion}
  %![Diffuse Reflexion; Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Diffuse_Reflexion.png)
  
  Lichtquelle im Unendlichen; Irradiance $E=\frac{A'_i}{A_i}I_{in}=I_{in}\cos(\phi)$
  
  Eingestrahlte Strahlstärke I in durch $A'_i$ verteilt sich durch die Projektion auf die größere Fläche $A_i$ Die Bestrahlungsstärke E (Irradiance) ist dadurch proportional zum Vergrößerungsfaktor der Fläche abgeschwächt.
  
  In Richtung Betrachter reflektierte Strahlstärke $I_{out}$ Aufgrund von Interferenz phasengleicher Lichtstrahlen $\rightarrow$ Projektion auf Normalenrichtung $\frac{I_{out}}{E_{refl}}=\cos(\phi)$
  \begin{itemize*}
    \item Senkrecht zur Oberfläche: Maximale Kohärenz (Addition)
    \item Parallel zur Oberfläche: n Keine Kohärenz (Auslöschung)
  \end{itemize*}
  
  %![Diffuse Reflexion Addition und Auslöschung; Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Diffuse_Reflexion_2.png)
  
  Annahme kohärentes Licht: Parallel zur reflektierenden Oberfläche findet sich zu jeder Punktlichtquelle immer eine gleichphasige Punktlichtquelle im Abstand $\frac{\lambda}{2}$, Auslöschung parallel zur Fläche,
  
  %![Diffuse Reflexion Betrachter; Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Diffuse_Reflexion_3.png)
  
  $$\frac{A_r}{A'_r}=\frac{1}{\cos(\phi)} \rightarrow L=\frac{I_{out}}{\cos(\phi)}=I_{refl}$$
  Ein Betrachter mit flachem Blickwinkel sieht Licht aus größerer Fläche $A_r$ durch Kombination dieser Effekte, kürzt sich der Einfluss des Betrachterwinkels $\cos(\phi)$ weg und es bleibt nur der Einfluss des Lichteinfallswinkels übrig: Strahldichte des reflektierten Lichtes: $L=I_{in}*k_d(\lambda)*\cos(\phi)$
  
  \paragraph{Spekuläre Reflexion}
  Spekuläre (gestreut spiegelnde) Reflexion:
  \begin{itemize*}
    \item Speckles (Fleckchen), bzw. (Micro-) Facetten sind einzeln jeweils "ideal"
    \item spiegelnd: Einfallswinkel $\phi$ = neg. Ausfallswinkel = $-\phi$.
    \item Die Ausrichtung der Microfacetten weichen von der Gesamtflächennormalen ab. $\rightarrow$ Statistische Abweichung von der Flächennormalen (z. B. Gauß-Verteilung)
    \item dadurch Streuung des Lichts (Keule) um den Winkel $\theta$ der idealen Spiegelung herum
    \item Je größer der Winkel $\theta$ zwischen idealer Spiegelrichtung und Richtung zum Betrachter, desto schwächer ist die Reflexion
    \item Modellierung meist per $\cos^k(\theta)$ (Phong-Beleuchtungsmodell) - nicht physikalisch begründet.
  \end{itemize*}
  
  %![Spekuläre Reflexion; Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Spekuläre_Reflexion.png)
  
  Gestreute Spiegelung im Phong Modell mit $L=I*k_s*\cos^k(\theta)$
  \begin{itemize*}
    \item glänzende Oberfläche: großer Exponent k (16,...,128); kleine Streuung $\epsilon$
    \item matte Oberfläche: kleiner Exponent k (1,...,2); große Streuung $\epsilon$
  \end{itemize*}
  
  Energieerhaltung $\rightarrow$ Verhinderung der Abnahme bei großen Exponenten $\rightarrow$ Für die Energieerhaltung wird ein zusätzlicher Normierungsfaktor benötigt:
  \begin{itemize*}
    \item physikalisch nicht korrekt:  $L=I*k_s*\cos^k(\theta)$
    \item gebräuchliche Normierung $\frac{k+2}{2\pi}$ somit: $L=I*k_s*\frac{k+2}{2\pi}*cos^k(\theta)$
  \end{itemize*}
  
  \paragraph{Remittierende Flächen}
  \begin{itemize*}
    \item Wegen der spektralen Unterschiede bei der Reflexion bleiben wir bei den spektralen physikalischen (radiometrischen) Größen!
    \item Erst im Auge bzw. im Bildsensor erfolgt die Wandlung in die wellenlängenintegralen photometrischen (colorimetrischen) Größe!
  \end{itemize*}
  
  Zunächst ideal diffus remittierende weiße Flächen $(\beta(\lambda) = 1)$:
  \begin{itemize*}
    \item Die von den Quellen in die Fläche $dA$ eingetragene Leistung führt zu einer Bestrahlungsstärke $E_{\lambda}$
    \item Bei vollständiger Reflexion $\beta(\lambda) = 1$ ist $E_{\lambda} = R_{\lambda}$ (spektrale Radiosity, spezifische spektrale Ausstrahlung).
    \item Der zugehörige spektrale Strahlungsfluss $d\phi = R_{\lambda} * dA = E_{\lambda} * dA$ wird bei ideal diffusen streuenden Oberflächen gleichmäßig über den Halbraum verteilt, wobei die Strahldichte (Lambertsches Gesetz) konstant ist.
  \end{itemize*}
  
  
  \subsection{ BRDF: Bidirektionale Reflexionsverteilungsfunktion}
  \paragraph{Bidirektionale Reflexion}
  \begin{itemize*}
    \item englisch Bidirectional Reflectance Distribution Function, BRDF
    \item eine Funktion für das Reflexionsverhalten von Oberflächen eines Materials unter beliebigen Einfallswinkeln
    \item Ziel: Oberfläche möglichst realistisch und physikalisch korrekt darstellen
    \item nach gewählter Genauigkeit sehr komplex
    \item in der Computergrafik wird meist eine vereinfachte Variante gewählt um Rechenzeit zu sparen
    \item erstmals 1965 definiert (Fred Nicodemus): $f_r(\omega_i, \omega_r)=\frac{dL_r(\omega_r)}{dE_i(\omega_i)}=\frac{dL_r(\omega_r)}{L_i(\omega_i)\cos(\theta_i)d\omega_i}$
    \item Eine BRDF beschreibt wie eine gegebene Oberfläche Licht reflektiert.
    \item Das Verhältnis von reflektierter Strahldichte (radiance) $L_r$ in eine Richtung $\vec{\omega}_r$ zur einfallenden Bestrahlungsstärke (irradiance) $E_i$ aus einer Richtung $\vec{\omega}_i$ wird "bidirectional reflectance distribution function"(BRDF) genannt.
    \item $p(\lambda)=\frac{L_r}{E_i}=[\frac{1}{sr}]$
    \item Die BRDF (für jeden Punkt x) ist eine 5-dimensionale skalare Funktion: $p(\lambda, \phi_e, \theta_e, \phi_i, \theta_i)$
    \item Keine Energie-Einheiten, nur Verhältniszahl!
    \item Kann durch Messung für verschiedene Materialien bestimmt werden (Messkamera/Normbeleuchtung)
    \item Eigenschaften der BRDF:
    \item Reziprozität: $\rho(\lambda)$ ändert sich nicht, wenn Einfalls- und Ausfallsrichtung vertauscht werden (wichtig für Ray-Tracing).
    \item $\rho(\lambda)$ kann anisotrop sein, d.h. der Anteil des reflektierten Lichtes ändert sich, wenn bei gleicher Einfalls- undAusfallsrichtung die Fläche um die Normale gedreht wird (Textilien, gebürstete Metalle, Metalleffektlacke)
    \item Superposition gilt, d.h. mehrere Quellen überlagern sich linear.
  \end{itemize*}
  
  Es ist in der Computergrafik üblich, die bidirektionale Reflektivität als Gemisch von ambienten, diffusen und spekularen Komponenten $\rho_d, \rho_s$ aufzufassen und
  einen ambienten Anteil $\rho_a$ zu addieren. Für eine Menge Q von Lichtquellen berechnen wir damit die gesamte reflektierte Strahlstärke: $L_r=p_a*E_a+\sum_{1\leq j \leq Q} E_j * (k_d*p_d + k_s*p_s)$ mit $k_d+k_s=1$ und Q= Anzahl der Lichtquellen
  
  \paragraph{Rendering-Equation}
  Für ambiente und gerichtete Lichtquellen aus der Hemisphäre ergibt sich eine spezielle Form der BRDF, die Render-Gleichung (Jim Kajiya 1986):
  \begin{itemize*}
    \item eine BRDF mit Integral über alle Lichtquellen (bzw. Hemisphären)
    \item $L_r=p_a + \int_{Omega} L*(k_d*p_d+k_s*p_s) \omega_i*n d\Omega$
  \end{itemize*}
  
  %![Rendering Equation; Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Rendering_Equation.png)
  
  \paragraph{Strahlungsquellenarten}
  \begin{itemize*}
    \item Ambiente Strahlung:
    \item es ist keine "eigentliche" Quelle zuordenbar
    \item stark vereinfachtes Modell für die Streuung der Atmosphäre, für viele "durchmischte" Strahlungsquellen, für indirekte Reflexionen
    \item Strahlung kommt von allen Seiten "Die Quelle ist überall und nirgends"
    \item keine Abhängigkeit von Winkeln und Entfernungen
    \item Beschreibung nur indirekt durch konstante Bestrahlungsstärke (Irradiance) von Flächen möglich
    \item $E=\frac{\Phi}{A}=E_a$
    \item Parallele Strahlung:
    \item Strahlung ist gerichtet und parallel (kollimiertes Licht, Strahlungsquelle im Unendlichen, Sonnenlicht)
    \item für derartige Quellen lässt sich kein Ort (aber uneigentlicher Ort, Richtung) angeben
    \item Wichtig sind die Richtung und die Strahlungsleistung, bezogen auf die senkrecht zur Ausbreitungsrichtung stehende Fläche (spezifische Ausstrahlung oder Radiosity $R_e$) $R=E_q=\frac{\Phi}{A_q}$
    \item für die Schattierungsrechnung lässt sich die Bestrahlungsstärke $E_e$ der Oberfläche (Flächenelement dA) berechnen: $E=\frac{\Phi}{A}=\frac{E_q*A_q}{A}=E_q*\cos(\phi) = E_q*V_I^T*n$
    \item Ideale Punktlichtquelle:
    \item für die Punktquelle ist der Ort bekannt und die Strahlstärke in alle Richtungen konstant: $I=\frac{\Phi}{\Omega}=konstant$
    \item die Bestrahlungsstärke eines physikalischen vorliegenden, beliebig orientierten Flächenelementes A ergibt sich zu:
    \item $E=\frac{\Phi}{A}=\frac{I*\Omega}{A}, \Omega=\frac{A}{r^2}*\cos(\phi)*\omega_r \rightarrow E=\frac{I}{r^2}*\cos(\phi)*\omega_r$
    \item zum Ausgleich der Adaptionsfähigkeit des menschlichen Auges wird in der Computergrafik oft der folgende Ansatz verwendet:
    \item $E=\frac{I}{c_1+c_2*|r|+c_3*r^2}*\cos(\phi)*\omega_r$
    \item Remittierende Flächen (radiometrische Betrachtung):
    \item Zur Berechnung der von der reflektierenden Fläche weitergegebenen Strahldichte L sind die weiter oben berechneten Bestrahlungsstärken E für die unterschiedlichen Quellen mit dem Faktor $\frac{\beta(\lambda)}{\pi\omega_r}$ zu bewerten
  \end{itemize*}
  
  \begin{tabular}{c | c | c}
    Quelle           & Reflexion & Spektale Strahldichte $L(\lambda)$                                                 \\\hline
    ambient          & diffus    & $L(\lambda)=\frac{E(\lambda)}{\pi\omega_r}*\beta(\lambda)$                         \\
    gerichtet        & diffus    & $L(\lambda)=\frac{E(\lambda)}{\pi\omega_r}*\cos(\phi)*\beta(\lambda)$              \\
    punktförmig      & diffus    & $L(\lambda) = \frac{I(\lambda)}{\pi r^2 }*\cos(\phi)*\beta(\lambda)$               \\
    gerichtet diffus & diffus    & $L(\lambda)=\frac{I(\lambda)}{\pi r^2 }* \cos^m(\theta)*\cos(\phi)*\beta(\lambda)$ \\
  \end{tabular}
  
  \subsection{ Beleuchtungsmodelle}
  Ein Beleuchtungsmodell ist eine Verfahren in der Computergrafik welches das Verhalten von Licht simuliert. Die Simulation unterscheidet dabei zwischen lokaler und globaler Beleuchtung:
  \begin{itemize*}
    \item Lokale Beleuchtungsmodelle:
    \item simulieren das Verhalten von Licht auf den einzelnen Materialoberflächen
    \item nur Beleuchtungseffekte welche direkt durch Lichtquellen auf einzelnen Objekt entstehen
    \item indirekte Beleuchtung bleibt zunächst unberücksichtigt
    \item Globale Beleuchtungsmodelle:
    \item simulieren die Ausbreitung von Licht innerhalb der Szene
    \item dabei wird die Wechselwirkung in der Szene beachtet (Schatttenwurf, Spiegelung, indirekte Beleuchtung)
  \end{itemize*}
  
  \paragraph{Phong-Modell}
  \begin{itemize*}
    \item lokales Beleuchtungsmodell (lässt sich durch BRDF beschreiben)
    \item eignet sich zur Darstellung von glatten, plastikähnlichen Oberflächen
    \item baut nicht auf physikalischen Grundlagen auf
    \item widerspricht dem Energieerhaltungssatz
    \item Reflexion des Lichts = ambienter+ ideal diffuser + ideal spiegelnder Reflexion
  \end{itemize*}
  
  %![Phong Modell; Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Phong_Modell.png)
  
  \begin{itemize*}
    \item Allgemein: $L=I_{out}=I_{ambient}+I_{diffus}+I_{specular}$
    \item Ambiente: $I_{ambient}=I_a * k_a$ mit $I_a$ Intensität des Lichtes und $k_a$ Materialkonstante
    \item Diffus: $I_{diffus}=I_{in}*k_d*\cos(\phi)$ mit $I_{in}$ Lichtstärke der Punktlichtquelle; $k_d$ empirischem Reflexionsfaktor; $\phi$ Winkel zwischen Oberflächennormale und Richtung des einfallenden Lichtstrahls
    \item Spiegelnd: $I_{specular}=I_{in}*k_s*\frac{n+2}{2\pi}*\cos^n({\theta})$ mit
    \item $I_{in}$ Lichtstärle des eingallendes Lichtstrahls der Punktlichtquelle
    \item $k_s$ empirisch bestimmter Reflexionsfaktor
    \item $\theta$ Winkel zwischen idealer Reflexionsrichtung des Lichtstrahls und Blickrichtung
    \item $n$ konstante Exponent zur Beschreibung der Oberflächenbeschaffenheit
    \item $\frac{n+2}{2\pi}$ Normalisierungsfaktor zur Helligkeitsregulierung
    \item Vollständige Formel: $I_{out}=I_a*k_a+I_{in}*k_d*\cos(\phi)+I_{in}*k_s*\frac{n+2}{2\pi}*\cos^n(\theta)$
  \end{itemize*}
  Unterschiedliche Definitionen sind möglich, z.B. mit mehrere Lichtquellen:
  \begin{itemize*}
    \item jeweiligen Komponenten für jede Lichtquelle separat berechnet
    \item diese werden anschließend aufsummiert
  \end{itemize*}
  
  \paragraph{Cook-Torrance}
  \begin{itemize*}
    \item Physik-basierte spekulare Reflexion:
    \item Microfacetten: Grundidee ähnlich Phong-Modell
    \item Statistische Abweichung der Microfacetten von der Flächennormalen (z. B. Beckmann-Verteilung)
    \item Streuung des Lichts (Keule) um den Winkel der idealen Spiegelung herum
    \item Berücksichtigt auch die gegenseitigen Abschattung (insbesondere bei flachen Lichtstrahlen)
    \item Vollständig physikbasiertes Modell, keine willkürlichen Reflexionskonstanten
    \item Aufwendige Berechnung (verschiedene Näherungsformeln existieren)
    \item Beckmann-Verteilung: $l_{spec}=\frac{exp(-\frac{tan^2(\alpha)}{m^2})}{\pi m^2 cos^4 (\alpha)}$, $\alpha=arccos(N*H)$
  \end{itemize*}
  
  \section{Schattierungsverfahren}
  \subsection{ Direkte Schattierung}
  Bisher:
  \begin{itemize*}
    \item Zerlegung gekrümmter Flächen in Polygone (meist Drei- oder Vierecke)
    \item Positionen der (Eck-)Punkte und Normalen im 3D sowie der Punkte im 2D-Bild sind bekannt (per Matrixmultiplikation für Transformationen und Projektion)
    \item Pixelpositionen für Polygone/Dreiecke im Bild per Scanline-Algorithmus
    \item lokale Beleuchtungsmodelle für 3D-Punkte (z.B. per Phong-Beleuchtungsmodell)
  \end{itemize*}
  
  Jetzt: Wie kommt Farbe (effizient) in die Pixel? Wie oft muss lokales Beleuchtungsmodell bei n Pixeln im Dreieck angewendet werden?
  
  \begin{tabular}{c | c | c}
    Verfahren       & Anz. & Idee                                                                                        \\\hline
    Flat-Shading    & 1    & eine Berechnung, dann gleiche Farbe für alle Pixel des Dreiecks/Polygons verwenden          \\
    Gouraud-Shading & 3    & pro Eckpunkt eine Farbe berechnen, dann lineare Interpolation (pro Dreieck) für jedes Pixel \\
    Phong-Shading   & n    & eine Berechnung pro Pixel, davor aber jeweils lineare Interpolation der Normalen pro Pixel  \\
  \end{tabular}
  
  $\rightarrow$ Phong-Beleuchtungsmodell in jedem der obigen Shading-Verfahren nutzbar
  
  $\rightarrow$ hier nur direkte Schattierung (nur lokal, wo sind die Lichtquellen), d.h. nicht global (wie bei Radiosity \& Raytracing)
  
  \paragraph{Flat-Shading}
  Arbeitsweise des Flat-Shadings
  \begin{itemize*}
    \item stets nur 1 Farbwert pro (ebener) Fläche,
    \item Stelle der Berechnung frei wählbar (möglichst repräsentativ),
    \item repräsentativ wäre z.B.: Punkt (Ort mit Normale) in der Mitte der Fläche
    \item $\rightarrow$ trivial für Drei- und Vierecke? $\rightarrow$ für Dreiecke und konvexe Vierecke!
  \end{itemize*}
  
  Auswirkungen
  \begin{itemize*}
    \item "flaches" Aussehen und Helligkeitssprünge an den Kanten, das ist:
    \item schlecht für Fotorealismus,
    \item gut für abstraktere technische Darstellungen und
    \item u.U. wichtig für realistische Darstellung kantiger Körper (insbes. wenn pro Eckpunkt nur eine Normale modelliert ist).
    \item schneller als die anderen Verfahren,
    \item u.U. genauso gut wie z.B. Phong-Shading, wenn z.B.:
    \item das Objekt sehr fein modelliert wurde oder
    \item sehr weit entfernt ist
    \item $\rightarrow$ d.h. nur ca. 1 Pixel pro Polygon/Dreieck gerendert wird (n==1)
  \end{itemize*}
  
  \paragraph{Gouraud-Shading}
  \begin{itemize*}
    \item Gouraud-Shading [H. Gouraud 1971] schattiert Dreiecke (bzw. aus Dreiecken zusammengesetzte Polygone) kontinuierlich,
    \item beseitigt damit die Diskontinuitäten des Flat-Shadings,
    \item meist gleiche Normalen pro Vertex, d.h. pro Dreieck wirken oft 3 verschiedene Richtungsvektoren statt nur eine Normale (Dreiecksmitte) wie beim Flat-Shading und
    \item lineare Interpolation der Schattierung (Intensitäten) im Inneren des Dreiecks aus den 3 Farbwerten der Eckpunkte.
    \item Es werden "Normalenvektoren" $n_i$ für jeden Eckpunkt $P_i$ des Polygons ermittelt bzw. ausgelesen.
    \item Die Herleitung der "Normalenvektoren" $n_i$ ist aus der Originaloberfläche (z.B. Zylinder, Kegel, Bèzier-Fläche) oder Nachbarpolygonen möglich.
    \item Für jeden Eckpunkt: Berechnung der Beleuchtungsintensität $I_i$ (z. B. nach dem Phong-Beleuchtungsmodell).
    \item Normalen $n_i$ der Eckpunkte werden entweder direkt aus den Flächen (z.B. Regelgeometrien, bei Kugel z.B. Richtung des Radiusvektors) oder aus den Flächennormalen der benachbarten Polygone durch flächengewichtete Mittelung berechnet.
    \item Die Schattierungsrechnung (RGB-Werte) erfolgt für die Eckpunkte und liefert die reflektierte Leuchtdichte $I_i$ . Zur Erinnerung, das Phong-Beleuchtungsmodell:
    \item $I_{out}=I_a*k_a+I_{in}*k_d*\cos(\phi)+I_{in}*k_s*\frac{n+2}{2\pi}*\cos^n(\theta)$
    \item $\cos(\phi)=V^T_I*n_i$, $cos^n(\theta)=(V^T_r * V_e)^n$
    \item Nach Anwendung des Beleuchtungsmodells an den Eckpunkten (auch Vertex-Shading genannt)
    \item Bei der Rasterkonvertierung wird zwischen den Eckwerte $I_i$ linear interpoliert und damit die Intensität jedes Pixels der Rasterlinie berechnet (Intensität I steht hier für die Leuchtdichte oder für Farbwerte usw.)
    \item Die Interpolation erfolgt nach dem gleichen arithmetischen Muster wie die Interpolation der x-Werte beim Polygonfüllalgorithmus, bzw. der $1/z$-Werte im z-Buffer-Verfahren (d. h. inkrementell, mit Ganzzahlarithmetik).
    \item Für farbige Oberflächen werden die Leuchtdichten an den Polygonecken durch RGB-Werte beschrieben und ebenso zwischen den Ecken linear interpoliert.
    \item Resultat: Kontinuierlich schattierte dreidimensionale Oberflächen
  \end{itemize*}
  
  %![Gourad Shading; Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Gourad-Shading.png)
  
  Artefakte des Gouraud-Shading, bedingt durch die lineare Interpolation:
  \begin{itemize*}
    \item Fehlen von gut ausgeprägten Glanzlichtern (verwischt oder verschwunden)
    \item Mach-Band-Effekt: ((helle) Bänder) Kontrastverstärkung durch das Auge an den Übergängen zwischen Polygonen
    \item Diese Artefakte werden im Folgenden genauer untersucht.
  \end{itemize*}
  
  \paragraph{Fehlende Glanzlichter}
  Auf Grund der linearen Interpolation von Intensitäten können Glanzlichter, die auf spekulare Reflexion zurückzuführen sind, verloren gehen oder abgeschwächt/verschmiert werden. Das wird umso kritischer, je spitzer die spekulare Reflexion ist (großes n im $\cos^n$- Term).
  
  Feinere Unterteilung der Oberfläche verbessert Resultat
  
  %![fehlende Glanzlichter; Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Gourad_Glanzlichter.png)
  
  \paragraph{Mach-Band-Effekt}
  Die lineare Interpolation der Leuchtdichte zwischen den Polygonkanten entlang der Rasterlinie führt zu einem Verlauf, der durch plötzliche Änderungen im Anstieg der Intensität gekennzeichnet ist (nicht stetig differenzierbar).
  
  Der Mach-Band-Effekt: physiologisches Phänomen (Ernst Mach, 1865)
  \begin{itemize*}
    \item Bei Sprüngen in der Helligkeitsänderung (c0-Stetigkeit, c1-Unstetigkeit, typisch für Approximation durch ebene Polygone beim Gouraud-Shading, z.B. Zylinder) stört dieser Effekt u. U. erheblich.
    \item Gleiche Information benachbarter Rezeptoren wirkt bei der weiteren visuellen Verarbeitung lateral hemmend auf die lokale Lichtempfindung.
    \item Modellhaft entstehen neben dem eigentlichen Helleindruck auch "Signale", die dem Helligkeitsgradienten (erste Ableitung) und dem Laplacefilter-Output (Laplacian of Gaussian / LoG, zweite Ableitung) entsprechen.
    \item Die Empfindung wird insgesamt nicht nur durch die Lichtintensität selbst, sondern auch durch die Überlagerung mit ihrer ersten und zweiten räumlichen Ableitung bestimmt.
    \item Das führt zu einer Verstärkung von Konturen an "Sprungkanten" (c0-Unstetigkeiten, Intensitätssprünge). In der dunklen Fläche zeigt sich eine dunklere, in den hellen Flächen eine hellere Kantenlinie. Dort, wo Konturen vorhanden sind, ist das vorteilhaft (evolutionäre Entwicklung der menschlichen visuellen Wahrnehmung), obwohl Täuschungen damit verbunden sind (photometrischer Eindruck).
    \item zunächst Kanten: Liegen eine helle und eine dunkle Fläche nebeneinander, beobachtet man einen dunklen Streifen auf der dunkleren Seite und einen hellen Streifen auf der helleren Seite (Kontrastverstärkung).
    \item Bei einer Abfolge von Flächen unterschiedlicher Graufärbung, die in sich keine Farbgraduierung haben, beobachten wir entlang der Grenzen machsche Streifen (nach Ernst Mach 1865). Dabei handelt es sich um helle und dunkle Streifen, die den Kontrast zwischen den Flächen verstärken. [Quelle: Wikipedia]
  \end{itemize*}
  
  \paragraph{Phong-Shading}
  Phong-Shading [Phong 1975]:
  \begin{itemize*}
    \item Lineare Interpolation der Normalenvektoren zwischen den Polygonecken anstelle von Interpolation der Intensitätswerte (bei Grafikkarten/-software als Pixelshader bekannt).
    \item Exakte Berechnung der $\cos^n$-Funktion im Phong-Beleuchtungsmodell für jedes Pixel : Glanzlichter werden erhalten!
    \item Keine Diskontinuität der ersten Ableitung: Mach-Band-Effekt wird vermieden!
  \end{itemize*}
  
  
  \subsection{ 3D-Rendering}
  Soll nur ein konvexes Objekt gerendert werden, dann ist die Entscheidung, welche Flächen zu zeichnen sind, einfach anhand der jeweiligen Normalen möglich.\\
  Annahme: mehrere konvexe Objekte oder auch konkave Objekte sollen gerendert werden. Verdeckungen sind also möglich!
  \begin{itemize*}
    \item Korrekte Behandlung von Verdeckungen bedarf spezieller Ansätze/Datenstrukturen (Lösung des Reihenfolgeproblems).
    \item Rein opake Szenen sind typischerweise wesentlich leichter zu implementieren als (teilweise) transparente (zusätzlich ein Berechnungsproblem).
    \item Zeichenreihenfolge ist teilweise wichtig (z.B. von hinten nach vorn),
    \item Algorithmen/Ansätze unterscheiden sich auch in der Granularität/Genauigkeit was auf einmal gezeichnet/sortiert wird:
    \item Objekte (ganze Objekte nach z-Position sortieren, dann jeweils zeichnen...)
    \item allg. (d.h. ggfs. überlappende) Polygone: Painters-Algorithmus,
    \item überlappungsfreie Dreiecke/Polygone: Depth-Sort-Algorithmus,
    \item Pixel: Z-Buffer-Verfahren (oft auch in Verbindung mit Obj.-Sort.)
    \item Beliebte Testszene sind sich zyklisch überlappende Dreicke, z.B.
  \end{itemize*}
  
  \paragraph{Painter’s-Algorithmus}
  \begin{itemize*}
    \item Gegeben sei eine 3D-Szene, bestehend aus grauen Polygonen mit diffus reflektierender Oberfläche, sowie eine gerichtete Lichtquelle.
    \item Für jedes Polygon wird die reflektierte Strahldichte L auf Basis des eingestrahlten Lichts (Richtung \& Stärke) und der Flächennormale berechnet:
    \item $I_{out} = L = I_{in}* k_d * \cos(\phi)$
    \item Die Polygone werden mittels perspektivischer Kameratransformation (4 x 4 Matrix) in das Kamera-Koordinatensystem (Bildraum) transformiert und nach absteigendem z-Wert (Distanz des Polygonschwerpunkts zum Betrachter) sortiert.
    \item Die sortierten Polygone werden der Reihe nach (entfernte zuerst) mit dem 2D-Polygonfüllalgorithmus in das Pixelraster der x/y-Bildebene konvertiert.
    \item Die Pixel für jedes Polygon werden per Overwrite-Modus mit dem Farbwert L (nach obiger Berechnung) im Bildspeicher gespeichert.
    \item Die Verdeckungsprobleme lösen sich durch die Reihenfolge quasi automatisch.
  \end{itemize*}
  
  Gleichnis: Der Algorithmus arbeitet wie ein Maler, der zuerst den Hintergrund und dann Schritt für Schritt das jeweils weiter vorn liegende Objekt (oder Polygon bzw. Dreieck) zeichnet - und dabei die dahinterliegenden verdeckt. ABER, potentielle Probleme des Painter’s-Algorithmus: selbst bei Dreiecken sind trotzdem falsche Verdeckungen möglich!
  
  \paragraph{Depth-Sort-Algorithmus}
  \begin{itemize*}
    \item Unterteilung in sich nicht überlappende und vollständig überdeckende Teilpolygone
    \item Ist in der Projektionsebene durch gegenseitigen Schnitt aller Polygone möglich (allerdings blickabhängig - muss in jedem Bild neu berechnet werden!).
    \item Die sichtbaren Teilpolygone können nun ausgegeben werden:
    \item Zeichnen der nicht überlappenden Teilpolygone
    \item Von den sich vollständig überlappenden Teilpolygonen wird nur das vordere gezeichnet.
  \end{itemize*}
  
  %![Depth Sorth Algorithmus; Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Depth-Sort-Algorithmus.png)
  
  \begin{itemize*}
    \item Eine einfache, nicht blickwinkelabhängige Unterteilung tut es in diesem Falle auch!
    \item Die Teilpolygone sollten dabei möglichst nicht größer sein als der Tiefenunterschied, damit sie in jeder Situation eindeutig sortiert werden können!
    \item Die 6 Teilpolygone können mittels Painter‘s Algorithmus korrekt sortiert und dargestellt werden
  \end{itemize*}
  
  Anwendungsbereiche des Painter's Algorithmus / Depth-Sort Algorithmus:
  \begin{itemize*}
    \item Einfache Szenen, kleine Objekte, die sich in den z-Werten hinreichend unterscheiden.
    \item Dort, wo keine Hardware-Unterstützung für 3D-Rendering angeboten wird (begrenzter Speicher, keine Z-Buffer Unterstützung).
    \item Viele 2D-Grafiksystem bieten bereits Polygonfüllverfahren an.
    \item Ähnliche Vorgehensweise wird auch für das Schattieren von semi-transparenten Flächen notwendig (s. später)!
  \end{itemize*}
  
  Als Sortierverfahren für Echtzeitsysteme eignet sich z.B. "Insertion-Sort":
  \begin{itemize*}
    \item Begründung: Von Bild zu Bild ändert sich die Tiefenwerte (und damit die Reihenfolge) der Polygone relativ wenig. Damit sind die Polygone beim nächsten Bild bereits mehr oder weniger vorsortiert (nur wenige Polygone) müssen neu einsortiert werden. Die Komplexität von Insertion-Sort wird bei bereits sortierten Listen linear (O-Notation / best case).
    \item Folglich tritt beim Painters-Algorithmus der best case sehr häufig ein (außer beim ersten Bild, wo man vom average case ausgehen kann- hier wird die Komplexität quadratisch).
  \end{itemize*}
  
  \paragraph{Z-Buffer-Verfahren}
  \begin{itemize*}
    \item Einer der einfachsten "visible surface"-Algorithmen (CATMULL 1974)
    \item Probleme des Painters-Algorithmus werden überwunden durch zusätzliche Berechnung des z-Wertes für jeden Punkt jedes Polygons und Speicherung des zur Projektionsebene nächstliegenden Farb- und Z-Wertes.
    \item Dazu ist ein zusätzlicher Speicher (z-Buffer) für jedes Pixel notwendig.
    \item Es sind weder Vorsortieren von Objekten noch Polygonzerlegung erforderlich (wenn alle Objekte opak sind).
  \end{itemize*}
  
  Initialisierung: Für alle Pixel
  \begin{itemize*}
    \item Setze Farbe auf Hintergrundfarbe (z.B. Weiß)
    \item Setze alle Z -Werte auf $\infty$ (max. ganzzahliger Wert)
    \item Setze Z min auf Wert der Near-Plane
  \end{itemize*}
  
  Für alle Polygone (im 3D-Kamerakoordinatensystem)
  \begin{itemize*}
    \item Rasterumwandlung in der Projektionsebene ($x_p/y_p$ Koordinaten) durch modifizierten 2D-Polygonfüllalgorithmus. Modifiziert heißt: zusätzliche Berechnung des z-Wertes für jedes Pixel
    \item Anwendung einer Write Pixel ZB-Prozedur:
    \item Wenn der z-Wert des aktuellen Pixels (im abzuarbeitenden Polygon) kleiner als der bereits abgespeicherte z-Wert ($z_p$) an dieser Position ist, wird im z-Buffer bei $x_p , y_p$ die Farbe sowie $z_p$ ) überschrieben (mit den neuen Werten).
    \item Sonst: alte Werte im Speicher bleiben erhalten
    \item Die näher an der Kamera liegen Pixel überschreiben somit die weiter weg liegenden.
    \item Pixelgenaue Sichtbarkeitsbestimmung und -behandlung der Polygone
  \end{itemize*}
  
  Berechnen der z-Werte durch lineare Interpolation:
  \begin{itemize*}
    \item Die Tiefenwerte sind auch nach der Ansichten-Transformation (View-Transformation) zunächst nur für die Eckpunkte gegeben.
    \item Zunächst erfolgt die lineare Interpolation der z-Werte entlang der Polygonkanten $P_i P_j$ für die y-Position der gerade aktuellen Scanline
    \item Danach wird mit dem Füllen der Bildzeile (z.B. durch einen konventionellen Polygonfüll-Algorithmus) die Interpolation der z-Werte entsprechend der x-Position in der Scanline (Bildzeile) fortgesetzt (pixelgenaues Befüllen des z-Buffers).
  \end{itemize*}
  
  Berechnung der z-Werte eines Pixels x/y:
  \begin{itemize*}
    \item Die y-Koordinate reicht zur Interpolation von $z_A$ und $z_B$ (Strahlensatz).
    \item Pixel-z-Wert $z_p$ wird äquivalent ermittelt, allerdings die Interpolationskoordinate jetzt x (y = const für die Rasterlinie)
    \item Die Werte $z_A, z_B, x_A, x_B$, in $z_p$ werden gleichzeitig mit den $x_A$-Werten (Schnitte) von einer Rasterlinie zur nächsten inkrementiert (s. Polygonfüllalgorithmus)
    \item Die Brüche bleiben in allen Ausdrücken rational.
    \item Die Ausdrücke für die z-Werte haben identische Form wie die der x-Werte beim Polygonfüllalgorithmus.
  \end{itemize*}
  
  Immer Ganzzahlarithmetik! (ähnlich wie x-Werte im Polygonfüllagorithmus)
  
  Beispiel: Mögliche Berechnungen eines Tiefenwertes der Pixel
  \begin{itemize*}
    \item Als Beispiel dient hier eine Tischplatte (Rechteck, Größe 3m x 1m) in der Perspektive
    \item Achtung: Eine lineare Interpolation der z-Werte im Bildraum (links) ist nicht wirklich korrekt! (höchstens als Näherung, OK für kleine nahe Flächen)
    \item $\frac{1}{z}$ kann exakt linear in x- \& y-Richtung interpoliert werden (Abbildung rechts).
    \item Da $z_1$ abnimmt, wenn z zunimmt, muss aber der z-Test invertiert werden!
    \item positive Auswirkung: Tiefeninfos naher Obj. werden mit höherer z-Genauigkeit gespeichert als weiter von der Kamera entfernte. Statistisch gesehen gibt es damit weniger "z-Fighting“-Effekte (z.B. bei Bewegungen willkürliche Farbwechsel zwischen den Farben von Objekten mit nahezu der selben Tiefeninfo im z-Buffer).
  \end{itemize*}
  
  %![Z-Buffer-Beispiel; Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Z-buffer-verfahren.png)
  
  \begin{itemize*}
    \item Das Ergebnis des Z-Buffer-Verfahrens ist vergleichbar mit dem Painters-Algorithmus.
    \item Es ist jedoch bei opaken Objekten keine vorgängige Sortierung der Polygone nötig. Sie können in beliebiger Reihenfolge gezeichnet werden.
    \item Die Interpolation der 1/z-Werte erfolgt im Polygonfüll-Algorithmus durch wenige Ganzzahl-Operationen (wie bei den x-Werten)
    \item Das Verfahren ist pixelgenau: Es werden auch zyklisch sich überlappende (und sogar räumlich sich durchdringende) Polygone korrekt dargestellt.
    \item Kaum Mehraufwand gegenüber dem 2D-Polygonfüllalgorithmus!
    \item Mögliches Problem: Korrekte Berücksichtigung von Transparenzen!
  \end{itemize*}
  
  \paragraph{Transparenz}
  Alpha-Blending-Verfahren: 
  \begin{itemize*}
    \item Annahme: Verwendung eines Z-Buffers
    \item Mit dem Alpha-Blending-Verfahren kann die transparente Überlagerung zweier Objekte im Bildspeicher wie folgt gelöst werden
    \item $C_f$ Farbe des Objekts im Vordergrund (kleinster z-Wert),
    \item $\alpha$ Opazität der Vordergrundfarbe, Wert zwischen 0 und 1 (bzw. 100%),
    \item $C_b$ Hintergrundfarbe (die im Bildspeicher für das entsprechende Pixel zuletzt eingetragene Farbe)
    \item Die resultierende Farbe C ergibt sich zu: $C=\alpha*C_f+(1-\alpha)*C_b$
    \item Für Alpha-Blending wird der Bildspeicher (mit z-Buffer) um den Opazitätswert $\alpha$ erweitert:
    \item Speicherbedarf pro Pixel typischerweise mindestens 48 Bit: R + G + B + Z + $\alpha$.
    \item Bei einer Auflösung des Bildschirms von 1.000.000 Pixel benötigen wir ca. 6MB Speicher.
    \item z-Wert und $\alpha$-Wert des Vordergrund Objektes werden nach dem Alpha-Blending in den Bildspeicher übernommen!
  \end{itemize*}
  
  %![Transparenz Probleme](Assets/Computergrafik_Transparenz-Fehler.png)
  
  \begin{itemize*}
    \item Reines Z-Buffering (ohne $\alpha$) ignoriert alle Objektepixel, die weiter entfernt sind als vorn liegende Objektpixel (siehe rechts, hier ist die Reihenfolge egal).
    \item Bei Berücksichtigung von $\alpha$-Werten (Transparenzen) ist die Renderreihenfolge für korrekte Ergebnisse aber sehr wichtig! (siehe Mitte bzw. links)
    \item Erläuterung zum Transparenz-Problem:
    \item Die Formel für $\alpha$-Blending berücksichtigt nur die Überlagerung des aktuellen Objektes mit dem davor existierenden Bildschirminhalt. Wird ein dazwischenliegendes Objekt nachträglich gezeichnet, dann kann die Farbe nicht korrekt bestimmt werden. Dies passiert aber beim Z-Buffering, da die Zeichenreihenfolge der Polygone beliebig ist.
    \item **Im Beispiel**
    \item Die opake grüne Kreisscheibe liegt zwischen dem hinteren Objekt (blau) und dem transparenten vorderen Objekt (rot), wird aber als letztes gerendert. $\rightarrow$ Grün kann Blau nicht mehr verdecken, denn Blau wurde zuvor schon mit Rot verrechnet (ist nun mit "vorderer" z-Koordinate im Z-Buffer hinterlegt). Dort, wo die grüne Kreisscheibe hinter dem transparenten Rot (bzw. dem nun Rot-Blau) liegt wird ein nicht korrekter Blauanteil gezeigt. Auch der weiße Hintergrund kann hinter dem transparenten Rot (insgesamt ein transparentes Rosa) nicht mehr vom Grün verdeckt werden!
    \item algorithmische Lösung des Problems:
    \item Zuerst: Darstellung aller opaken Objekte ($\alpha$ = 1) nach dem Z-Buffering (reihenfolgeunabhängig)
    \item Dann Sortieren aller semitransparenten Polygone nach der Tiefe und Zeichnen nach dem Painters-Algorithmus unter Berücksichtigung des Z-Buffers mittels Alpha-Blending!
    \item Restfehler: sich zyklisch überlappende oder sich durchdringende semi-transparente Flächen $\rightarrow$ exakte Behandlung durch die vorn beschriebenen Maßnahmen (Unterteilung der Polygone notwendig!)
  \end{itemize*}
  
  \section{Globale Beleuchtung}
  \begin{itemize*}
    \item BRDF: physikbasiertes, lokales Reflektionsmodell (Lichtquelle auf Material) $\rightarrow$ Funktion von Einfalls-, Betrachterwinkel, Wellenlänge (bzw. -breiche)
    \item Rendergleichung (Kajiya) = BRDF, Integral über alle Lichtquellen (bzw. Hemisphäre)
    \item Approximation durch lokales Phong-Beleuchtungsmodell $\rightarrow$ für "einfache" Materialien und Lichtquellen "korrekt genug"
    \item direkte (lokale) Schattierungsverfahren (Flat-, Gouraud- und Phong-Shading)
    \item Was noch fehlt: Interreflektionen zwischen Objekten...
    \item globale Beleuchtung, d.h. jede Fläche kann als Lichtquelle dienen
  \end{itemize*}
  
  \subsection{ Ray-Tracing}
  einfaches Ray-Tracing: Strahlenverfolgung, nicht rekursiv
  \begin{itemize*}
    \item Strahlen vom Augpunkt (Ursprung des Kamerakoordinatensystems) durch jedes Pixel des Rasters senden $\rightarrow$ keine Löcher
    \item Schnittpunktberechnung mit allen Objekten $\rightarrow$ Schnittpunkt mit dem größtem z-Wert stammt vom sichtbaren Objekt
    \item Strahlverfolgung (Anwendung des BRDF-Reziprozitätsprinzips) und Aufsummierung der (Lichtquellen-)Anteile aufgrund von material- und geometrieabhängigen Parametern (ggf. neben Relflektion auch Brechung) $\rightarrow$ Ergebnis: Helligkeits-/Farbwert pro Pixel
    \item Bestimmung der diffusen und spekularen Lichtreflexion nach dem Phong-Beleuchtungsmodell
    \item Bis hier nur einfache, lokale Beleuchtung (keine Spiegelung, Schatten, indirekte Beleuchtung)! $\rightarrow$ Vorzüge des RT kommen erst bei rekursivem Raytracing zum Tragen!
  \end{itemize*}
  
  
  \paragraph{Rekursiver Ansatz}
  \begin{itemize*}
    \item Berechnung von Sekundärstrahlen am Auftreffpunkt (Reflexions- und Schattenfühler)
    \item Annäherung der Interreflektionen (mehrfache Reflexion zwischen den Objekten) durch ideale Spiegelung, d.h. Spiegelung des primären Strahls an $\bar{n}$ im Auftreffpunkt und Erzeugung des sekundären Strahls
    \item beim Auftreffen des Strahls auf ein weiteres Objekt B Berechnung der diffusen und spekularen Reflexion der jeweiligen Lichtquelle (Schattenfühler, Phong-Modell) sowie Erzeugung eines weiteren Strahls durch ideale Spiegelung
    \item Addition der Sekundärstrahlen an Objekt B zum Farbwert des Pixel am Objekt A (Anteil bei jeder weiteren Rekursion meistens fallend, da reflektierter Anteil bei jeder Reflexion abgeschwächt wird) $\rightarrow$ Rekursion kann abgebrochen werden, wenn Beitrag vernachlässigbar!
  \end{itemize*}
  
  
  \paragraph{Brechungseffekte}
  Transparenz unter Berücksichtigung der Brechung beim Ray-Tracing: Richtung des gebrochenen Strahls berechnet sich aus dem Einfallswinkel zum Normalenvektor sowie den material- und wellenlängenabhängen Brechungsindices.
  $$\eta_{e\lambda}*sin(\theta_e) = \eta_{t\lambda}*sin(\theta_t)$$
  Beispiel Luft-Glas: $\eta_{\text{Luft, rot}}*\sin(\theta_{\text{Luft}})=\eta_{\text{Glas,rot}}*sin(\theta_{\text{Glas}}) \Rightarrow 1.0*\sin(30^\circ)=1.5*sin(\theta_{\text{Glas}})\rightarrow \theta_{\text{Glas}} \approx \arcsin(\frac{\sin(30^\circ)}{1.5})\approx 20^\circ$
  
  %![Brechungseffekt; Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Brechungseffekt.png)
  Die Farbe im betrachteten Punkt wird nicht durch die Farbe von Hintergrundobjekt B1 (wie im Fall nichtbrechender Transparenz) sondern durch die Farbe von B2 beeinflusst!
  
  Berechnung des Einheitsvektors $\vec{V}_t(\vec{V}_e,n,\theta_t)$ in Richtung der Brechung:
  \begin{itemize*}
    \item An Grenzflächen mit unterschiedlichen Brechungsindizes tritt neben der Transparenz ($\vec{V}_t$) auch Reflexion (Komponente mit der Richtung $\vec{V}_r$) auf.
    \item $\vec{M}$ ist ein Einheitsvektor (Länge=1) mit der Richtung von $\vec{n}*\cos(\theta_e)-\vec{V}_e$ und
    \item es gilt: $\vec{M}*sin(\theta_e)=\vec{n}*\cos(\theta_e)-\vec{V}_e \rightarrow \vec{M}=\frac{\vec{n}*\cos(\theta_e)-\vec{V}_e}{\sin(\theta_e)}$
    \item Effekte an transparentem Material:
    \item Simulation brechungsbedingter Verzerrungen wird so möglich (z.B. bei optischen Linsen, Wasser).
    \item Transparentes und reflektierendes Material erzeugt 2 weiter zu verfolgende Sekundärstrahlen.
  \end{itemize*}
  
  
  
  \paragraph{Erweiterungen}
  Unzulänglichkeiten des einfachen rekursiven Ansatzes:
  \begin{itemize*}
    \item Reale Objekte sind eher diffus spekular, d.h. ein ganzes Set von Sekundärstrahlen wäre zu verfolgen.
    \item Die ideale Spiegelung zur Erzeugung von Sekundärstrahlen ist eine sehr starke Vereinfachung
    \item Aus der Umkehrbarkeit von Licht- und Beleuchtungsrichtung ließe sich eine Menge von Sekundarstrahlen aus dem Phong-Modell $(\cos^n(\theta)$-Term) ermitteln.
    \item Aus Aufwandsgründen (rein theoretisch wären unendlich viele Sekundärstrahlen zu berücksichtigen) muss vereinfacht werden, z.B. Monte-Carlo-Ray-Tracing
  \end{itemize*}
  
  **Monte Carlo Ray-Tracing**:
  \begin{itemize*}
    \item Reflexion ist selten ideal spekular, meist entsteht ein Bündel von Strahlen
    \item Ansatz: Verfolgung mehrerer "zufälliger" Sekundärstrahlen, deren Beitrag zum Farbwert des Pixel statistisch gewichtet wird.
    \item Je gestreuter die Reflexion, um so mehr Sekundärstrahlen sind nötig. Sehr breite Remissionskeulen oder gar diffuse Interreflexionen sind wegen des Aufwandes nicht (bzw. nur schwer) behandelbar.
  \end{itemize*}
  
  Beleuchtungsphänomen Kaustik:
  \begin{itemize*}
    \item Das Licht der Lichtquelle werde zuerst spekular, dann diffus reflektiert. Beispiel: Lichtstrahlen, die von Wasserwellen reflektiert auf eine diffuse Wand auftreffen.
    \item Vom Auge bzw. Pixel ausgehendes Ray Tracing versagt wegen des vorzeitigen Abbruchs der Rekursion am diffus remittierenden Objekt.
    \item Inverses Ray Tracing [Watt/Watt 1992] : Man erzeugt einen von der Lichtquelle ausgehenden Strahl und reflektiert diesen an glänzenden Oberflächen. Auch Photon Mapping kann hier helfen.
    \item Die reflektierten Lichtstrahlen wirken als zusätzliche Lichtquellen, die dann zu diffusen Reflexionen führen können.
  \end{itemize*}
  
  Optimierungsmöglichkeiten (einfache Hüllgeometrien, Raumzerlegung, ...):
  \begin{itemize*}
    \item Berechnung von achsenparallelen Hüllquadern (Bounding Boxes) oder Hüllkugeln (Bounding Spheres) um Objekte aus mehreren Polygonen.
    \item Zunächst Test, ob der Strahl die Hülle schneidet und falls ja
    \item $\rightarrow$ Schnittpunktberechnung von Strahl mit allen Polygonen in der Hülle
    \item $\rightarrow$ zunächst Berechnung des Schnittpunktes mit der jeweiligen Polygonebene
    \item $\rightarrow$ danach effizienter Punkt-im-Polygon-Test
    \item Effiziente Zugriffsstruktur auf die Hüllquader: Bäume für rekursive Zerlegungen des 3D-Raumes (Octrees), Binary-Space-Partition-Trees
    \item Verwendung von direktem, hardware-unterstützten Rendering (z.B. Gouraud- oder Phong-Shading) anstelle von einfachem, nichtrekursivem Ray-Tracing, nur bei Bedarf Erzeugung von Sekundärstrahlen.
    \item Verwendung von Hardware mit RTX-Unterstützung
  \end{itemize*}
  
  \paragraph{Zusammenfassung}
  Anwendung:
  \begin{itemize*}
    \item Erzeugung realistischerer Bilder als bei lokalem Shading, da indirekte (spekuläre) Beleuchtungsphänomene physikalisch (geometr. und radiometr.) viel genauer als bei direkter Schattierung berechnet werden können.
    \item Ray-Tracing ist aufgrund der hohen Komplexität für interaktive Anwendungen (oft noch) wenig geeignet (hardware- und szenenabhängig), mögliche Lösung: Vorberechnung der Bildsequenzen im Stapel-Betrieb (batch mode)
    \item Fotorealistisches Visualisieren (Designstudien usw.)
    \item Computeranimation in Filmen
    \item Interaktive Programme (CAD, Spiele) verwenden noch eher direktes Rendering mit Texturen (shadow map, environment map) um Schatten, Spiegeleffekte oder Brechung zu simulieren.
    \item Aufwendige Teiloperation: Geometrischer Schnitt im Raum:
    \item für jedes Pixel: Berechnung des Schnittes eines Strahles mit potentiell allen Objekten der Szene (einfaches Ray-Tracing, ohne Rekursion)
    \item z.B. Bildschirm mit 1.000 x 1.000 Pixeln und 1.000 Objekten
    \item **Rekursives Ray-Tracing** für den ideal spiegelnden Fall: Anzahl der Operationen wächst zusätzlich, d.h. Multiplikation des Aufwandes mit der Anzahl der Reflexionen und Refraktionen und Lichtquellen (Schattenfühler) $\rightarrow$ für ca. 4 Rekursionsstufen bei 2 Lichtquellen haben wir etwa $4*(2 + 1) = 12$ Millionen Strahlen, was schon bei 1.000 Objekten 12 Milliarden Schnittoperationen bedeutet.
    \item **Monte-Carlo-Ray-Tracing** für die Approximation diffuser Anteile: Weiteres Anwachsen der Anzahl an erforderlichen Operationen durch zusätzliche Verfolgung sehr vieler Sekundärstrahlen (durchschnittlich 10 pro Reflexion) $\rightarrow$ Mehrere 100 Millionen bis Milliarden Strahlen (bzw. Billionen Schnittoperationen)
    \item Durch **effiziente räumliche Suchstrukturen** kann die Anzahl der tatsächlich auszuführenden Schnittoperationen wesentlich reduziert werden. Die Anzahl der Schnitte steigt nicht mehr linear (sondern etwa logarithmisch) mit der Anzahl der Objekte (siehe räumliche Datenstrukturen). Damit ist auch bei großen Szenen nur noch die Anzahl der Strahlen wesentlich $\rightarrow$ je nach Bildauflösung und Verfahren, mehrere Millionen bis Milliarden Strahlen!
    \item Eigenschaften des Ray-Tracing-Verfahrens:
    \item Implementierung ist konzeptionell einfach + einfach parallelisierbar.
    \item Hohe Komplexität durch Vielzahl der Strahlen, deshalb meistens Beschränkung auf wenige Rekursionen.
    \item Exponentielle Komplexität bei Monte-Carlo-Ray-Tracing bzw. wenn alle Objekte gleichzeitig transparent (Brechung) und reflektierend sind.
    \item Resultat:
    \item RT ist sehr gut geeignet, wenn die spiegelnde Reflexion zwischen Objekten (und/oder die Brechung bei transparenten Objekten) frei von Streuung ist.
    \item Die diffuse Reflexion zwischen Objekten wird beim Ray-Tracing durch ambiente Terme berücksichtigt. Eine bessere Beschreibung dieser Zusammenhänge ist mit Modellen der Thermodynamik möglich.
    \item Weitere Ansätze:
    \item Cone-Tracing - statt eines Strahles wird ein Kegel verwendet, der die Lichtverteilung annähert [Watt/Watt 1992].
    \item Radiosity (siehe Abschnitt weiter unten)
    \item Photon Mapping (nächster Abschnitt)
  \end{itemize*}
  
  \subsection{ Photon Mapping}
  \begin{itemize*}
    \item Verfahren von Henrik Wann Jensen 1995 veröffentlicht
    \item angelehnt an Teichencharakter des Lichts
    \item 2-stufiges Verfahren
    \item Quelle: Vorlesung von Zack Waters, Worcester Polytechnic Inst.
  \end{itemize*}
  
  %![Photonmapping; Quelle Vorlesung Computergrafik 2020](Assets/Computergrafik_Photonmapping.png)
  
  \begin{enumerate*}
    \item Phase: Erzeugung der Photon Map
    \item Photonenverteilung in der Szene: Von der Lichtquelle ausgestrahlte Photonen werden zufällig in der Szene gestreut. Wenn ein Photon eine Oberfläche trifft, kann ein Teil der Energie absorbiert, reflektiert oder gebrochen werden.
    \item Speichern der Photonen in der Photon Map Daten enthalten also u.a. Position und Richtung beim Auftreffen sowie Energie für die Farbkanäle R,G,B
    \begin{itemize*}
      \item Photon wird in 3D-Suchstruktur (kd-Baum) gespeichert (Irradiance cache)
      \item Reflektionskoeffizienten als Maß für Reflektionswahrscheinlichkeit (analog Transmissionswahrscheinlichkeit)
      \item dafür: Energie bleibt nach Reflexion unverändert. Neue Richtung wird statistisch auf Basis der BRDF gewählt.
    \end{itemize*}
    \item  Phase: Aufsammeln der Photonen aus Betrachtersicht (gathering)
    \begin{itemize*}
      \item Verwende Ray-Tracing um für den Primärstrahl von der Kamera durch einen Pixel den Schnittpunkt x mit der Szene zu bestimmen. Basierend auf den Informationen aus der Photon Map werden für x folgende Schritte ausgeführt:
      \begin{enumerate*}
        \item Sammle die nächsten N Photonen um x herum auf durch Nächste-Nachbar-Suche in der Photon Map (N = konst., z. B. 10)
        \item S sei die (kleinste) Kugel, welche die N Photonen enthält.
        \item Für alle Photonen: dividiere die Summe der Energie der gesammelten Photonen durch die Fläche von S ($\rightarrow$ Irradiance) und multipliziere mit der  BRDF angewendet auf das Photon.
        \item Dies ergibt die reflektierte Strahldichte, welche von der Oberfläche (an der Stelle x) in Richtung des Beobachters abgestrahlt wird.
      \end{enumerate*}
    \end{itemize*}
  \end{enumerate*}
  
  \subsection{ Radiosity}
  Grundprinzip des Radiosity-Verfahrens:
  \begin{itemize*}
    \item Ansatz: Erhaltung der Lichtenergie in einer geschlossenen Umgebung
    \item Die Energierate, die eine Oberfläche verlässt, wird Radiosity (spezifische Ausstrahlung) genannt.
    \item Die gesamte Energie, die von einer Oberfläche (Patch, Polygon) emittiert oder reflektiert wird, ergibt sich aus Reflexionen oder Absorptionen anderer Oberflächen (Patches, Polygone).
    \item Es erfolgt keine getrennte Behandlung von Lichtquellen und beleuchteten Flächen, d.h. alle Lichtquellen werden als emittierende Flächen modelliert.
    \item Da nur diffuse Strahler (Lambertstrahler) betrachtet werden, herrscht Unabhängigkeit der Strahldichte vom Blickwinkel vor.
    \item Die Lichtinteraktionen werden im 3D-Objektraum (ohne Berücksichtigung der Kamera) berechnet.
    \item Danach lassen sich beliebig viele Ansichten schnell ermitteln (Ansichtstransformation, perspektivische Projektion, Verdeckungsproblematik, Interpolation).
  \end{itemize*}
  
  Die gesamte von Patch $A_s$ stammende Strahldichte an der Stelle von $dA_r$ ist: $L_r=\beta_r(\lambda)*\int_{A_s}\frac{L_s}{\pi * r^2}*\cos(\theta_s)*\cos(\theta_r)*dA_s$ (s=Sender, r=Reveiver)
  %![Radiosity; Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Radiosity.png)
  
  Für das Polygon $A_r$ ist die mittlere Strahldichte zu ermitteln!
  $$L_r=\beta_r(\lambda)*\frac{1}{A_r}*\int_{A_r}\int_{A_s}\frac{L_s}{\pi*r^2}*\cos(\theta_s)*\cos(\theta_r)*dA_s*dA_r$$
  Die Geometrieanteile aus dieser Gleichung werden als Formfaktoren bezeichnet (+Sichtbarkeitsfaktor $H_{sr}$).
  $$F_{sr}=\frac{1}{A_R}\int_{A_r}\int_{A_s}\frac{\cos(\theta_s)*\cos(\theta_r)}{\pi*r^2}*H_{sr}*dA_s*dA_r, H_{sr}=\begin{cases}1\rightarrow A_s \text{ sichtbar}\\ 0\rightarrow A_s \text{ unsichtbar}\end{cases}$$
  Für Flächen, die klein im Verhältnis zu ihrem Abstand sind, ergibt sich eine Vereinfachung des Formfaktors. In diesem Fall können die Winkel $\theta_s,\theta_r$ und Radius r über den zu integrierenden Flächen als konstant (Mittelwerte) angenommen werden.
  $$F_{sr}=A_S \frac{\cos(\theta_s)*cos(\theta_r)}{\pi*r^2}*H_{sr}$$
  
  Bei dicht benachbarten Flächen gelten die obigen, vereinfachenden Annahmen u.U. nicht mehr. Es müsste exakt gerechnet oder in diesen Bereichen feiner untergliedert werden. 
  Wird statt $\beta \lambda \beta$ vereinfachend ein konstanter Remissionsfaktor R (R diff im monochromatischen Fall oder $R_{diff R}, R_{diffG}, R_{diffB}$ für die drei typischen Farbkanäle) eingeführt, so ergibt sich zwischen der Strahldichte $L_r$ der bestrahlten Fläche und der Strahldichte $L_s$ der bestrahlenden Fläche der folgende Zusammenhang: $L_r=R_r*F_sr*L_s$
  
  Jedes Patch wird nun als opaker Lambertscher (d.h. ideal diffuser) Emitter und Reflektor betrachtet (d.h. alle Lichtquellen werden genauso wie einfache remittierende Flächen behandelt, allerdings mit emittierendem Strahldichte-Term $L_{emr}$). $L_r=L_{emr}+R_r*\sum_S F_{sr}*L_s$
  
  Es ergibt sich schließlich als Gleichungssystem:
  $$ \begin{pmatrix} 1-R_1F_{11} & -R_1F_{12} &...& -R_1F_{1n}\\ 1-R_2F_{21} & -R_2F_{22} &...& -R_2F_{2n}\\ \vdots & \vdots & \ddots & \vdots \\ 1-R_nF_{n1} & -R_nF_{n2} &...& -R_nF_{nn} \end{pmatrix} * \begin{pmatrix} L_1\\L_2\\\vdots\\L_n \end{pmatrix} = \begin{pmatrix} L_{em1}\\L_{em2}\\\vdots\\L_{emn} \end{pmatrix}$$
  Das Gleichungssystem ist für jedes Wellenlängenband, das im Beleuchtungsmodell betrachtet wird, zu lösen ($R_r, R_{rR}, R_{rG}, R_{rB}, L_{emr}$ sind im Allgemeinen wellenlängenabhängig).
  
  \paragraph{Adaptives Refinement}
  Adaptives Radiosity-Verfahren:
  \begin{itemize*}
    \item vereinfachte Formfaktor-Berechnung ist ungenau bei eng beieinander liegenden Flächenstücken (z. B. in der Nähe von Raumecken), oder bei kontrastreichen Übergängen)
    \item deshalb adaptive Unterteilung solcher Flächen in feinere Polygone
  \end{itemize*}
  
  Im adaptiven Radiosity-Verfahren werden deshalb große Flächen (insbesondere dort wo Flächen relativ hell sind im Vergleich zur Nachbarfläche $\rightarrow$ kontrastreiche Übergänge) unterteilt. Die Notwendigkeit wird durch erste Berechnung mit grober Unterteilung geschätzt.
  
  \paragraph{Progressive Refinement}
  \begin{itemize*}
    \item das Radiosity-Verfahren ist sehr aufwendig (Bestimmung aller Formfaktoren, Anwendung des Gauß-Seidel-Verfahrens zum Lösen des Gleichungssystems)
    \item jedoch viel weniger Samples als Monte-Carlo-Raytracing (1 mal pro Kachel-Paar mal Anzahl Interationen)!
    \item beim progressive Refinement ist die inkrementelle Approximation des Ergebnisses des exakten Algorithmus durch ein vereinfachtes Verfahren wünschenswert
    \item ein entsprechender Algorithmus, der die Patches einzeln behandelt, stammt von Cohen, Chen, Wallace und Greenberg
    \item akkumuliert mehr Energie in jedem Schritt, verletzt Gleichgewicht der Strahlung $\rightarrow$ Korrektur notwendig:
    $L_r^{k+1}=L_{emr} + R_r*\sum_s F_{sr}* L_s^k$
  \end{itemize*}
  
  
  \paragraph{Radiosity Eigenschaften}
  \begin{itemize*}
    \item ausschließlich Berücksichtigung der diffusen Reflexion
    \item blickwinkelunabhängig, direkt im 3D-Raum arbeitend
    \item realistische Schattenbilder, insbesondere Halbschatten (viele, bzw. flächig ausgedehnte Lichtquellen)
    \item sehr rechenintensiv, deshalb meist Vorausberechnung einer Szene in 3D
    \item $\rightarrow$ Beleuchtungsphänomene wie z.B. indirektes Licht (besonders augenfällig in Innenräumen, Museen, Kirchen, Theaterbühnen usw.) sind mit Radiosity sehr gut/realistisch darstellbar.
    \item $\rightarrow$ die Kombination von Radiosity und Ray Tracing (und ggfs. anderen Verfahren/Filtern etc) ermöglicht computergenerierte Szenen mit sehr hohem Grad an Realismus.
  \end{itemize*}
  
  \subsection{ Zusammenfassung}
  \begin{itemize*}
    \item BRDF für physikbasierte, lokale Berechnung der Reflexion von Lichtquellen als Funktion von Einfallswinkel und Betrachterwinkel (evtl. wellenlängenabhängig, oder einfach durch RGB)
    \item Rendergleichung (Kajiya) = BRDF, Integral über alle Lichtquellen (bzw. Hemisphäre)
    \item für indirekte Beleuchtung / Global Illumination: (verschiedene algorithmische Verfahren unter Verwendung der lokalen Beleuchtung (BRDF)
    \item (rekursives) Raytracing (einfache Spiegelung, Brechung, Schatten)
    \item Monte Carlo RT, (gestreute Spiegelung, diffuse Reflexion), Backward Ray Tracing (Kaustik), Photon Mapping $\rightarrow$ jedoch extrem rechenaufwendig!)
    \item Radiosity (indirekte diffuse Reflexion - sichtunabhängige Voraus-berechnung in 3D für statische Szenen)
    \item verschiedene Verfahren können kombiniert werden um die globale Beleuchtungsphänomene effizienter zu berechnen. - z. B. Radiosity + Ray Tracing: Indirekte diffuse Beleuchtung + Spiegelung und Schatten, etc.
  \end{itemize*}
  
  \section{Texture Mapping}
  \subsection{ Bildbasiertes Rendering}
  \paragraph{Überblick}
  \begin{itemize*}
    \item typische Anwendung: Applizieren von 2D-Rasterbildern auf 3D-Modellen
    \item Beispiele: Hausfassade, Holz-, Marmor-, Steintexturen, Tapeten, Stoffe etc.
    \item 3D-Objekte mit relativ einfachen Polygonen modelliert. - Details als Texturen, (d.h. als Raster-Bilder) - gelegentlich "Impostor" genannt.
    \item Texture-Mapping als Erweiterung des einfachen Pattern-Filling (siehe. Polygonfüllalgorithmus)
    \item als Verallgemeinerung auch Image-based Rendering genannt
    \item Verwendung unterschiedlicher 3D-Transformationen und Beleuchtungsarten
    \item Spezielle Effekte! (Reflexionen, Schatten, ..)
  \end{itemize*}
  
  Erzeugung von Texturen:
  \begin{itemize*}
    \item "reale" Texturen aus realen rasterisierten/digitalen Fotografien (aus Pixeln = "Picture-Elementen" werden Texel = "Texturelemente") vs.
    \item "berechnete" Texturen $\rightarrow$ synthetische Computergrafik-Bilder:
    \item vorberechnete reguläre Texturen (basieren auf Texeln) vs.
    \item nach Bedarf erzeugte statistische bzw. prozedurale Texturen (Absamplen von mathematischen Beschreibungen, ggf. beliebig genau)
  \end{itemize*}
  
  Anwendung von Texturen - Grundprinzipien:
  \begin{itemize*}
    \item Transformation des Texturraums in den Bildraum der Darstellung: Verwendung unterschiedlicher geometrischer Transformationen (je nach Anwendungszweck)
    \item Resampling: transformiertes Texturraster wird aufs Bildraster "gerundet"
    \item Filtern: Verhindern/Abmildern von resampling-basierten Aliasing-Effekten
    \item Beleuchtung: RGB-Werte der Textur dienen als Materialattribute bei der Beleuchtungsrechnung
  \end{itemize*}
  
  Unterschiedliche Arten des Texturmappings (Transformationsfunktion):
  \begin{itemize*}
    \item Parametrisches Mapping: Ein Rasterbild wird auf ein 3D-Polygon aufgebracht, indem man den Eckpunkten (x,y,z) des Polygons 2D-Texturkoordinaten (u,v) explizit zuordnet.
    \item affines Texturmapping: direkte affine Abbildung der Textur auf projizierte Polygone im Bildraum
    \item perspektivisches Texturmapping: Zwischenabbildung der Textur in den 3D-Objektraum und perspektivische Projektion in den Bildraum
    \item Projektives Texturmapping: Verwendung unterschiedlicher Projektionsarten (parallel, perspektivisch, eben, zylindrisch, sphärisch)
    \item Environment-Mapping: Spiegelung der Textur an der Oberfläche (bzw. Refraktion) mit entsprechender Verzerrung
    \item Transformation abhängig von Kameraposition!
  \end{itemize*}
  
  \paragraph{Affines Texturemapping}
  Durch Zuordnung von 3 Punkten im Bildraster zu den entsprechenden 3 Punkten im Texturraster erhält man ein Gleichungssystem mit 6 Gleichungen und 6 Unbekannten $(a_u , b_u , c_u , a_v , b_v , c_v )$:
  \begin{itemize*}
    \item $P_1: u_1=a_u*x_1+b_u*y_1+c_u; v_1=a_v*x_1+b_v*y_1+c_v$
    \item $P_2: u_2=a_u*x_2+b_u*y_2+c_u; v_2=a_v*x_2+b_v*y_2+c_v$
    \item $P_3: u_3=a_u*x_3+b_u*y_3+c_u; v_3=a_v*x_3+b_v*y_3+c_v$
  \end{itemize*}
  
  Für jedes Pixel(x,y) im Polygon: Resampling der Textur(u,v) bei der Rasterkonvertierung (Polygonfüllalgorithmus)
  
  Für jedes Pixel(x,y) finde die Texturkoordinaten(u,v), d.h.:
  \begin{itemize*}
    \item Rückwärtstransformation vom Ziel zum Original $\rightarrow$ keine Löcher im Bild!
    \item ABER: Texturkoordinaten können übersprungen oder wiederholt werden!
    \item Störsignale (Aliasing) $\rightarrow$ Filterung notwendig!
  \end{itemize*}
  
  Affines Mapping der Vertices x,y auf u,v $\rightarrow$ lineare Interpolation der u/v-Texturkoordinaten zwischen den Vertices für jedes Pixel (ähnlich wie RGB- bzw. Z-Werte im Polygonfüllalgorithmus, durch Ganzzahlarithmetik)
  
  %![Affines Texturmapping; Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Affines-Texturmapping.png)
  
  Problem: Durch affine 2D-Abbildungen können nur Transformationen wie Rotation, Skalierung, Translation, Scherung in der Bild-Ebene abgebildet werden, aber keine Perspektive! $\rightarrow$ Abbildungsfehler zwischen den Eckpunkten! (kleine Dreiecke $\rightarrow$ kleiner Fehler!)
  
  \paragraph{Perspektivisches Texture-Mapping}
  Beispiel: affine 3D-Abbildung der Textur per 4x4-Matrix auf 3D-Modell: 
  Texturraum $\rightarrow$ Objektraum: Rotation, Translation, Skalierung (...) dann Objektraum $\rightarrow$ Bildraum: Projektion (selbe wie bei Geometrieprojektion)
  
  %![Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Perskeptivisches-Texture-Mapping.png)
  
  entspricht affinem Textur-Mapping mit einem zusätzlichen Zwischenschritt, der Bestimmung der Objektraumkoordinaten:
  \begin{itemize*}
    \item Matrix $M_{to}$: Koordinatentransformation vom Texturraum in den 3D- Objektraum (affine Abb.: 3D-Translation, -Rotation, -Skalierung)
    \item Matrix $M_{oi}$ : Koordinatentransformation vom Objektraum in den Bildraum (Kameratransformation, perspektivische Abbildung)
    \item Matrix $M_{ti}$: gesamte Koordinatentransformation vom Texturraum direkt in den Bildraum: $M_{ti} = M_{to}*M_{oi}$
    \item Matrix $M_{ti}^{-1}$: Inverse Koordinatentransformation vom Bildraum zurück in den Texturraum
  \end{itemize*}
  
  $\rightarrow$ 4x4-Matrix für homogene Koordinaten. Perspektivische Abbildung im Bildraum durch Division durch z, für jedes Pixel (wesentlich aufwendiger als lineare Interpolation)
  
  Vergleich: Perspektivisches / Affines Texture Mapping:
  \begin{itemize*}
    \item perspektivisches Textur-Mapping liefert auch bei perspektivischer Ansicht geometrisch korrekte Bilder
    \item etwas höherer Berechnungsaufwand pro Polygon, da für jedes Polygon zwei Transformationsmatrizen und eine inverse 4x4-Matrix bestimmt werden müssen
    \item wesentlich höherer Berechnungsaufwand pro Pixel: Matrixmultiplikation plus (floating-point) Division!
    \item bei affinem Textur-Mapping können hingegen einfach die Texturkoordinaten (u/v) zwischen den Polygonecken linear interpoliert werden:
    \item ähnlich wie bei anderen Attributen (z. B. x-Koordinate (s. Edge-Scan), r/g/b-Werte (s. Gouraud-Shading), Tiefenwerte (1/z) funktioniert dies inkrementell und mit Ganzzahlarithmetik (als Teil des Polygonfüllalgorithmus)
    \item je kleiner die Polygone im Bild, desto kleiner der Fehler beim affinen Texturemapping (Ansatz: feinere Unterteilung der Polygone in kleinere Dreiecke $\rightarrow$ dafür jedoch mehr Polygone!)
  \end{itemize*}
  
  \paragraph{Textur-Mapping mit Polygon-Schattierung}
  Eingliederung in die Render Pipeline
  \begin{itemize*}
    \item Bestimmung der zum Polygon gehörenden sichtbaren Pixel im Bildraum (Polygonfüllalgorithmus)
    \item Ermittlung der zur jeder Pixelkoordinate gehörenden Texturkoordinate mit Hilfe der inversen Transformationsmatrix $M_{ti}^{-1}$
    \item Ermittlung der Farbe des zu setzenden Pixels aus dem Texturraster (und gegebenenfalls weitere Schattierung aus der Beleuchtungsrechnung)
    \item Beleuchtungsrechnung, z.B.: Multiplikation der Helligkeit einer beleuchteten diffusen weißen Oberfläche mit den r/g/b-Werten der Textur (Lambert Modell)
  \end{itemize*}
  
  \paragraph{Weitere Texturarten}
  \begin{itemize*}
    \item Texturen mit Transparenz: RGBA-Wert zu jedem Pixel gespeichert, d.h. beim Rendern wird Alpha Blending mit der Hintergrundfarbe angewendet
    \item Video Texture: zeitlich veränderliche Textur, d.h. dynamische Veränderungen wie z.B. Feuer, Rauch (mit Alpha-Blending über Hintergrund / Billboard) oder Fernseher in der Wohnung mit Programm“ (ohne Alpha-Blending)
    \item Solid Textures:
    \item Textur als 3D-Array (u/v/w-Koordinaten, bzw. Voxel) $\rightarrow$ gespeicherte RGB(A)-Werte pro Voxel
    \item Abbildung über affine 3D-Transformation xyz auf uvw
    \item beim Rendern entweder auf Vertices angewendet und dann für Pixel linear interpoliert oder für jedes Pixel einzeln angewendet (Pixelshader)
    \item Anwendungsbsp.: Schnitt durch Material (z.B. Massivholz, Marmor) oder Volume Rendering (Überlagerung von Schichten) mit Alpha Blending, z.B. Computertomoraphie (CT-Daten)
    \item ggfs. auch Videotextur als Spezialfall einer Solid Texture: Zeit als 3. Dim.
  \end{itemize*}
  
  %\paragraph{Projektives Textur-Mapping
  Berechnung der Texturkoordinaten aus der aktuellen Position der einzelnen Polygone (Analogie: Projektion eines Diapositivs auf ein räumliches Objekt)
  
  Beispiel: Parallelprojektion mit fixer Position des Projektors zum Objekt
  \begin{itemize*}
    \item 2D-Textur (Bsp. Gitter aus Millimeterskalen)
    \item Parallelprojektion der Textur auf einen Zylinder mit abgeschrägten Endflächen
    \item Projektion ist relativ zum Objekt definiert, d.h. die Textur bewegt sich mit dem Körper, sofern man diesen bewegt
    \item markierte Bereiche (1 bzw. 2) haben auf Zylinder stets identische Positionen
    \item keine explizite Zuordnung von uv-Koordinaten zu Polygoneckpunkten notwendig, weniger Modellieraufwand!
  \end{itemize*}
  
  Anwendungsbeispiele für projektives Textur-Mapping (Parallel- oder Zentralprojektion):
  \begin{itemize*}
    \item Darstellung geometrischer Eigenschaften (geometrische Details, parallel, fixe Position des Projektors zum Objekt, senkrecht zur Fläche)
    \item einfache Darstellung von Parameterlinien (sofern die Textur senkrecht auf die Projektionsebene projiziert wird, parallel, fixiert bezgl. Objekt)
    \item Simulation eines Lichtkegels (Repräsentation der Leuchtdichteverteilung der Lichtquelle (Lichtfeld) als Rasterbild in einer Textur, zentral, fix in Weltkoordinaten)
  \end{itemize*}
  
  Zylindrisches Textur-Mapping:
  \begin{itemize*}
    \item radiale Projektion der Textur-Koordinaten auf eine Zylinderoberfläche
    \item visueller Effekt für zylinderähnliche Objekte ähnlich zu parametrischem Textur-Mapping, z.B. Etikett auf Flasche, Dose, etc.
  \end{itemize*}
  
  Sphärisches Textur-Mapping:
  \begin{itemize*}
    \item Zentralprojektion der Textur-Koordinaten auf eine Kugeloberfläche
    \item Vorteil des projektiven Texturmappings: Eine explizite Zuordnung der 3D-Punkte zu Texturkoordinaten mit stetiger Fortsetzung der Parametrisierung an den Polygongrenzen entfällt $\rightarrow$ weniger Modellieraufwand!
  \end{itemize*}
  
  \paragraph{Environment Mapping}
  Spezialfall des projektiven Textur-Mapping:
  \begin{itemize*}
    \item Simulation der Reflexion der Umgebung an einer reflektierenden Fläche
    \item Darstellung abhängig von der Position des Betrachters sowie von den Normalen der reflektierenden Fläche
    \item Textur entspricht der Lichtquelle für die Beleuchtung durch die Umgebung (Environment Map): Sphere Map bzw. Cube Map
  \end{itemize*}
  
  Mapping der Textur auf die spiegelnde Oberfläche:
  \begin{itemize*}
    \item Aussenden eines Strahls vom Auge auf einen Punkt der spiegelnden Oberfläche
    \item Ermittlung der Reflexionsrichtung entsprechend dem Einfallswinkel des Strahl zur Flächennormale
    \item damit Bestimmung des zu reflektierenden Punktes in der Umgebung, d. h. des entsprechenden Textur-Pixels aus der Environment Map
  \end{itemize*}
  
  Grundannahme beim Environment Mapping:
  \begin{itemize*}
    \item relativ große Entfernung der reflektierten Objekte von der spiegelnden Fläche
  \end{itemize*}
  
  Erzeugung einer Cube Map-Textur:
  \begin{itemize*}
    \item Aufteilung der Environment Map in sechs Bereiche, die den sechs Flächen eines Würfels um die spiegelnde Fläche herum entsprechen
    \item Rendern der Umgebung sechs mal mit einem Kamera-Sichtfeld von jeweils 90 Grad aus dem Mittelpunkt des Würfels
    \item Alternativ: Digitale Aufnahme und Einpassen der sechs Flächen mittels Image Warping in die jeweiligen Zonen der Environment Map
    \item Strahlverfolgung: Sehstrahl wird an den Eckpunkten des Objekts (entsprechend den Normalen) gespiegelt und dreidimensional mit den 6 Wänden der Cube Map geschnitten.
    \item Daraus ergibt sich eine Zuordnung von Objektkoordinaten (x/y/z) und Texturkoordinaten (u/v).
    \item Die Transformation kann wie beim perspektivischen Texturmapping berechnet werden und beim Rasterisieren für die dazwischen liegenden Pixel angewendet werden.
    \item Effekt ähnlich wie bei Raytracing, jedoch geometrisch angenähert (gespiegelte Objekte sind nur als 2D-Raster-Bild repräsentiert)
    \item keine aufwändigen Strahl-Objektschnitte (wie beim Raytracing) notwendig (Sehstrahl wird von den dargestellten Dreiecksecken zurückgerechnet!)
    \item Näherung wird ungenau, wenn das spiegelnde Objekt weit weg ist von der Kameraposition, welche für die Generierung der Cube-Map verwendet wurde
    \item nur Einfachreflexion
    \item Cube Maps können dynamisch (durch Offline-Rendering in Texturbuffer) generiert werden. Dadurch auch bewegte gespiegelte Objekte in Echtzeit darstellbar
    \item Beachte: gespiegeltes Dreieck kann auf zwei oder mehrere Wände der Cube Map fallen. Dies kann durch mehrfaches Mapping und Clipping gelöst werden.
  \end{itemize*}
  
  Environment Mapping [Haeberli/Segal 1993] für Kugel und Torus: 
  \begin{itemize*}
    \item Unterschiedliche Ausrichtung der Objektoberfläche sorgt für korrekte Verzerrung der spiegelnden Objekte. Die Darstellung der spiegelnden Objekte (Geometrie und Material) steht beim Environment-Mapping im Vordergrund und nicht die korrekte geom. Darstellung gespiegelter Objekte!
    \item Alle Raumrichtungen werden auf der Kugeloberfläche abgebildet. Je nach Aufnahmegeometrie mehr oder weniger großer blinder Fleck“ hinter der Kugel.
  \end{itemize*}
  
  %![Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Environment-Map-Kugel.png)
  
  Erstellung einer Spherical-Environment-Map-Textur:
  \begin{itemize*}
    \item spiegelnde Kugel in der Mitte einer Szene
    \item Fotografie der Kugel mit einer Kamera sehr großer (unendlicher) Brennweite aus großem (unendlichem) Abstand (parallele Projektionsstrahlen)
    \item Entstehung einer kreisförmigen Region in der Textur-Map mit den Tangenten jeweils an den Außenkanten
    \item Texturwerte außerhalb des Kreises werden nicht benötigt
    \item Wahl der Blickrichtung(-en) wichtig für spätere Anwendung!
  \end{itemize*}
  
  Anwendung einer Spherical Environment Map:
  \begin{itemize*}
    \item Zur Bestimmung der Texturkoordinate eines dargestellten Punktes wird zuerst die Normale n an diesem Punkt bestimmt.
    \item Die Normale n wird auf die x/y- Ebene projiziert. Die Koordinaten des projizierten Normalenvektors entsprechen den Texturkoordinaten in der Sphere Map, welche die an dieser Stelle reflektierte Umgebung zeigt.
    \item Merke: Die Reflexion ist nicht von der Lage des reflektierenden Punktes abhängig (nur von der Normalenrichtung).
  \end{itemize*}
  
  Environment Map in latitude-/longitude-Koordinaten:
  \begin{itemize*}
    \item Spiegelung wird aus Richtung des gespiegelten Strahls in Winkelkoordinaten (lat/long) berechnet
    \item entweder pro Pixel (Pixel-Shader) oder pro Vertex mit anschließender (linearer) Interpolation pro Pixel
    \item keine Berücksichtigung der Position des spiegelnden Objekts
    \item korrekt nur für unendlich entfernte gespiegelte Objekte $\rightarrow$ geeignet zur Spiegelung weit entfernter Objekte (Landschaften, große Räume auf relativ kleinen Objekten)
  \end{itemize*}
  
  
  High-dynamic Range Imaging (HDRI) Env-Maps:
  \begin{itemize*}
    \item enthalten "gesamte Dynamik" des Lichts (als Floating Point Farbwerte)
    \item Wesentlich realistischere Bilder!
    \item Tone Mapping: berechnete HDRI-Bilder werden anschließend auf die Dynamik des Monitors reduziert
    \item Refraktion / Brechung mit Environment Maps:
    \item wie Spiegelung, jedoch Sekundärstrahl aus Sehstrahl über Brechungsindex und Oberflächennormale, statt gespiegelt
    \item Beispiel: Glas als Polygonflächen mit Rückseite + Normalen (2-fache Brechung!) + Spiegelung als Multi-Pass (Überlagerung zweier Effekte)
    \item kann im Zusammenhang mit Cube-Maps, Spherical oder Lat/Long Environment Maps angewendet werden
  \end{itemize*}
  
  
  \subsection{ Mip-Mapping}
  Was? aus Originaltextur Bildung einer Menge jeweils kleinerer Texturen (halbe Kantenlänge)
  
  Wozu? Vermeidung/Abmilderung von Aliasing-Effekten durch "Vorfilterung" und Anwendung der passend aufgelösten Textur(-en) (1 Pixel $\approx$ 1 Texel) per bilinearer Filterung oder trilinearer Filterung
  
  \paragraph{Sampling-Artefakte}
  Aliasing-Effekte durch Koordinatentransformation:
  \begin{itemize*}
    \item Pixel der Textur und Pixel des dargestellten Bildes weisen (aufgrund der Bildtransformation) im Allgemeinen unterschiedliche Rastergrößen auf.
    \item simpler Ansatz: Berechnung der transformierten Texturkoordinaten als Floating-Point-Werte und Rundung auf ganze Zahlen
    \item bei inverser Transformation vom Zielbild zurück zur Textur dann keine Lücken im Bild, aber die Pixel der Textur können ausgelassen oder mehrfach verwendet werden (Bildpixel werden genau einmal angewendet)
    \item durch das Resampling der Textur auf das resultierende Bildraster entstehen oft Aliasing-Artefakte
  \end{itemize*}
  
  Zwei wesentlich unterschiedliche Situationen:
  \begin{itemize*}
    \item Abbildung mehrerer Texturpixel auf ein Bildpixel (Unterabtastung) oder
    \item Abbildung eines Texturpixels auf mehrere Bildpixel ( Überabtastung)
    \item Filteroperationen zur Interpolation der Bildpixel-Färbung in jedem Fall notwendig, insbesondere bei der Unterabtastung wird ein vorheriges Tiefpassfiltern und Resampling notwendig!
    \item Ansonsten Verletzung des Abtasttheorems / Nyquistfrequenz!
  \end{itemize*}
  
  Beispiel perspektivische Verkürzung der Schachbretttextur:
  \begin{itemize*}
    \item in Realität eigentlich starke Verkleinerung der Textur bei größerer Entfernung!
    \item $\rightarrow$ Moiré Muster - Originaltextur ist an diesen entfernten Stellen im Bild zur Laufzeit nicht mehr erkennbar (Unterabtastung, aus mehreren Texeln, welche "hinter einem Pixel liegen“, wird nur einer ausgwählt)
    \item Treppenstufen im Nahbereich resultieren aus Überabtastung (mehrere Pixel teilen selben Texel)
    \item Lösung: Textur muss vorher passend durch Tiefpassfilter in der Auflösung reduziert werden $\rightarrow$ Aufbau und Anwendung einer Mip-Map
    \item Ziel der Mip-Map: stets 1 Texel pro Pixel bereitstellen
  \end{itemize*}
  
  
  \paragraph{Aufbau}
  \begin{itemize*}
    \item In 3D-Szenen können Körper mit der selben Textur vom Betrachter unterschiedlich weit weg sein. $\rightarrow$ im Bild oft Unterabtastung (Minification) oder Überabtastung (Magnification) und entsprechende Aliasing-Effekte durchs Resampling!
    \item Ansatz: Vorberechnung derselben Textur für verschiedene Entfernungen
    \item Stufe 1: volle Auflösung
    \item Stufe 2: halbe Auflösung in jeder Richtung $(1/2)$
    \item ...
    \item Stufe k: Auflösung $(1/2)^k$
    \item Stufe n: niedrigste Auflösung (je 1 Pixel für z.B. R, G und B)
    \item Speicherbedarf:
    \item (hypothetische) Annahme: Anordnung im Array (getrennt f. RGB) $\rightarrow$ Alle niedrigen Auflösungen verbrauchen zusammen nur ein Viertel des Speicherplatzes
    \item Mip steht für lat. multum in parvo = viel (Information) auf wenig (Speicherplatz)
    \item niedrige Auflösungsstufen werden durch Filterung aus den höheren berechnet:
    \item einfach: z.B. Mittelwert aus 4 Pixeln (Box-Filter) oder
    \item aufwendiger: z.B.: Gaußfilter (siehe Kap. Bildverarb.)
  \end{itemize*}
  
  \paragraph{Anwendung}
  \begin{itemize*}
    \item Beispiel: OpenGL-Filteroperationen im Bildraum (zur Laufzeit ausgeführt):
    \item GL\_NEAREST: Annahme des Wertes des nächstliegenden Textur-Pixels
    \item GL\_LINEAR: bilineare Interpolation: gewichteter linearer Durchschnitt aus einem 2x2-Feld der am nächsten liegenden Texturpixel
    \item Genauere Interpolationsverfahren (z.B. bikubisch) gelten als zu aufwendig für Echtzeitanwendung
    \item Beispiel für stark vergrößerte Textur:
    \item Aus der Nähe betrachtet, wird das Texturraster auf dem Bildraster entsprechend skaliert (vergrößert).
    \item durch Runden der Texturkoordinaten (d.h. ohne Filterung)
    \item mit bilinearem Filter gewichtete Texturfarbwerte proportional zum Abstand vom gerundeten Koordinatenwert
  \end{itemize*}
  
  \paragraph{Zusammenfassung}
  Aufbau der Mip-Map (als Vorverarbeitungsschritt beim Rendering):
  \begin{itemize*}
    \item Speicherung der Originaltextur
    \item rekursive Speicherung der geringer aufgelösten Texturen (je 1/2 Kantenlänge) bis hinunter zu einem einzelnen Pixel
  \end{itemize*}
  
  Vorteile:
  \begin{itemize*}
    \item Filter-Operationen können bei Initialisierung der Textur vorausberechnet werden
    \item nur ein Drittel zusätzlicher Speicherplatzbedarf
  \end{itemize*}
  
  Darstellung mit Mip-Map Texturen (zur Laufzeit)
  \begin{itemize*}
    \item Auswahl der passenden Auflösungsstufe k Skalierung berechnet aus der Entfernung zum Betrachter und der perspektivischen Verkürzung (siehe Kameratransf.): $d/z = (1/2)^k \rightarrow k = log_2(z)-log_2(d)$
    \item Transformation der Pixel zwischen den Textur-Eckkoordinaten der gewählten Auflösung auf das Polygon im Bildraum
    \item typ. Verwendung der linearen Filter zur Vermeidung von Aliasing-Effekten durch Trilineare Filterung: zusätzlich zu bilinearem Filteren in einer Mip-Map-Stufe wird linear gewichtet zwischen zwei Mip-Map-Stufen (auf-, bzw. abgerundete Werte von k) interpoliert: z. B. wenn $k = 2.3 \rightarrow 30\% Anteil_{k=3}$ und $70\% Anteil_{k=2}$
  \end{itemize*}
  
  
  \paragraph{Anti-Aliasing}
  Anti-Aliasing durch trilineare Filterung:
  \begin{itemize*}
    \item Durch die perspektivische Verkürzung wird eine weiter hinten liegende Textur verkleinert und im Vordergrund vergrößert. Bei einer Skalierung kleiner als 1 überspringt die gerundete inverse Texturtransformation Pixel in der Textur (minification). Die im Bildraum gesampelten Texturpixel werden somit "willkürlich" ausgewählt. Dadurch können Treppenstufen und Moiré-Muster entstehen (Aliasing-Effekt: linkes Bild). Durch Mip-Mapping werden an diesen Stellen geringer aufgelöste (gefilterte) Texturen verwendet (Rechtes Bild: Mit Mip-Mapping und tri-linearer Filterung wird ein Anti- Aliasing-Effekt erreicht)
    \item Vergrößerte Darstellung: Trilinearen Filterung = lineare Filterung zwischen den zwei aufeinander-folgenden (am besten passenden) Mip-Map-Stufen + bilineare Filterung in jeder der beiden Stufen. $\rightarrow$ Kantenglättung, Tiefpassfilter (Mittelwert / hier Grauwerte)
  \end{itemize*}
  
  %![Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Mapping-Anti-Alising.png)
  
  \paragraph{Rip-Maps}
  Anisotrope Filterung: 
  \begin{itemize*}
    \item z.B. bei flacher Aufsicht ist die Verkleinerung in y-Richtung viel stärker als in x-Richtung!
    \item Ohne spezielle Maßnahmen für diesen Fall müsste jeweils die Mip-Map-Stufe mit der kleinsten Auflösung verwendet werden, sonst treten wieder Aliasing-Artefakte auf!
    \item $\rightarrow$ Dies führt zur unscharfen Texturabbildung.
    \item Abhilfe: Anisotrope Mip-Maps (= Rip-Maps, Rectangular Mip-Maps)
  \end{itemize*}
  
  Anisotropic Mip-Map (Rip-Map):
  \begin{itemize*}
    \item Verschiedene Auflösungsstufen in x- und y-Richtung werden erzeugt, sodass für jede Situation die richtige Auflösung gefunden werden kann ohne beim Resampling das Abtast-theorem zu verletzen.
    \item Aber: Vierfacher Speicherbedarf gegenüber höchster Auflösung
  \end{itemize*}
  
  \subsection{ Weitere Texturarten}
  \paragraph{Bump-Map}
  \begin{itemize*}
    \item Reliefartige Texturen: Herkömmliche Texturen sehen aus der Distanz zwar akzeptabel aus, von Nahem betrachtet erscheinen sie flach.
    \item Grund: keine korrekte 3D-Beleuchtung, Abschattung, keine Verdeckung, etc.
    \item Idee: Verwendung zusätzlicher Texturen, welche Tiefeinformationen beinhalten
  \end{itemize*}
  \begin{itemize*}
    \item Bump Map: Offset zur Polygonebene in Richtung der Normale als Grauwert“ der Textur kodiert
    \item Polygon: als Schnitt mit Normalenrichtung
    \item Anwendung des Offsets auf Polygonfläche (Drehung): Die Normale wird als Gradient der Bumpmap berechnet. Die Beleuchtung wird daraus wie bei der Normalmap pro Pixel berechnet.
    \item Ein Offset“ wird nicht berücksichtigt! $\rightarrow$ Als Konturen nicht erkennbar!
  \end{itemize*}
  
  %![Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_Bumpmap.png)
  
  \paragraph{Normal-Map}
  \begin{itemize*}
    \item Normal-Map: Normalen Vektor x/y/z als RGB-Wert kodiert
    \item Polygon: als Schnitt mit Normalenrichtung
    \item Anwendung der Normal-Map auf Polygonfläche: Die Normale der N-Map modifiziert die Flächennormale (räumliche Drehung). Bei der Beleuchtungsberechnung wird für jedes Pixel die modifizierte Normale verwendet.
    \item Ein "Offset" wird nicht berücksichtigt! $\rightarrow$ Als Konturen nicht erkennbar!
  \end{itemize*}
  
  \paragraph{Parallax-Map}
  \begin{itemize*}
    \item Parallax Map Tomomichi Kaneko et al. 2001
    \item Ausgangsdaten: Bump Map
    \item Die u/v-Koordinaten der angezeigten Textur werden Entsprechend der Blickrichtung beim Look-up um $\delta u = h * \tan(\phi)$ verschoben. Die daraus resultierende Verzerrung verstärkt den 3D-Effekt, allerding ohne korrekte Berücksichtigung der Verdeckung
    \item Anwendung des Offsets auf Polygonfläche (Drehung): Anwendung der Bump Map des Offests auf Polygonfläche (räuml. Drehung der Modellkoord.) Die Normale wird als Gradient der Bumpmap berechnet. Die Beleuchtung wird daraus wie bei der Normalmap pro Pixel berechnet.
  \end{itemize*}
  
  \paragraph{Displacement-Map}
  \begin{itemize*}
    \item Ausgang: Wiederum Bump Map, jedoch Bestimmen des korrekten Schnitts eines Sehstrahls mit der Bump Map durch iterative Suche des Schnittpunktes
    \item Finde $u_0$ , sodass $u-u' = h(u') * \tan(\phi)$ mittels Bisektion entlang dem Sehstrahl
    \item Bei Mehrdeutigkeit: Finde $u_0$ am weitesten weg von $u$ $\rightarrow$ korrekte Verdeckung
    \item Silhouetten: Auch u/v-Koordinaten außerhalb der Polygongrenzen müssen berücksichtigt werden!
    \item aufwendige Shader Programme nötig
  \end{itemize*}
  
  \paragraph{Zusammenfassung}
  \begin{itemize*}
    \item DECAL (Abziehbild) RGBA-Werte ohne Berücksichtigung der Beleuchtung (emmisiv, evtl. mit Alpha Wert (A) für transparente Anteile)
    \item DIFFUSE: RGB-Werte werden als diffuser Farbanteil mit Beleuchtung verrechnet
    \item Graustufen: Helligkeitsweit wird mit dem diffusen Materialfarben mutlipliziert.
    \item Specular Map: Wie bei Diffuse Texture Map, jedoch für spekulären Anteil
    \item Normal Map: Normalisierte Normalenrichtung (als 2farbiges Rasterbild). Dient zur Modulierung der Flächennormalen und wird bei der Beleuchtung berücksichtigt. Farbwerte kommen aus der Materialkonstante des Polygons, oder aus der Diffuse Map (bzw. Specular Map). Ergibt aus der Ferne eine dreidimensionalen (reliefartige) Struktur.
    \item Bump Map: Statt der Normalen wird eine Erhöhung (in Richtung der Normalen) kodiert (grauwertiges Rasterbild). Die Normalenrichtung wird daraus als Gradient (Differenz zweier benachbarter Pixel) bei der Darstellung abgeleitet. Danach Beleuchtung wie Normal Map.
    \item Parallax Map: zusätzlich Pixelverschiebung als Funktion der Höhe und Kamerarichtung
  \end{itemize*}
  
  \subsection{ Shadow Mapping}
  \begin{enumerate*}
    \item Durchgang:
    \begin{itemize*} 
      \item Erzeugen der Shadow Map
      \item Darstellung (mit z-Werten) aus Sicht der Lichtquelle
      \item Kamera Koordinaten in der Lichtquelle zentriert (Matrix L)
      \item z-Puffer als Textur speichern
    \end{itemize*}
    \item Durchgang:
    \begin{itemize*}
      \item Kamera Ansicht: View Matrix: V (ebenfalls mit z-Puffer)
      \item $\rightarrow$ Um den Schatten zu erzeugen benötigen wir Shader mit Lookup in der Shadow Map-Textur:
      \item 4x4-Matrix: $M = V^{-1}*L$
    \end{itemize*}
  \end{enumerate*}
  
  %![Quelle Computergrafik Vorlesung 2020](Assets/Computergrafik_ShadowMap.png)
  
  Shadow map look-up:
  \begin{itemize*}
    \item Transformiere jedes Pixel aus dem Kameraraum in den Lichtraum
    \item $p'=L*V^{-1}*p$
    \item Vergleiche transformierte z-Werte $(p'_z)$ mit den z-Werten der Shadow Map $(z_s)$
    \item $(p'_z>z_s)$: im Schatten - keine Beleuchtung von der Lichtquelle
    \item sonst: Punkt ist von der Lichtquelle her sichtbar, wende Beleuchtung in der Schattierung des Pixels an
  \end{itemize*}
  
  \paragraph{Probleme}
  Z-fighting beim Schattentest:
  \begin{itemize*}
    \item Schattentest $(p_z' <= z_s )$ sollte für beleuchtete Pixel korrekt $(p'_z = z_s)$ ergeben.
    \item Aufgrund der Rechenungenauigkeit der Fließkomma-Arithmetik wird Gleichheit selten erreicht!
    \item Beleuchtete Polygone schatten sich teilweise selbst ab.
    \item Lösung: kleiner Offset im Schattentest: $IF (p'_z <= z_s + Offset...)$
    \item durch das Offset wird sichergestellt, dass keine falschen Schatten entstehen
  \end{itemize*}
  
  Uniform Shadow-Map
  \begin{itemize*}
    \item Probleme: zu niedrige Auflösung der Shadow Map im Nahbereich, Großteil der Shadow Map ist irrelevant für Kameraansicht
  \end{itemize*}
  
  Perspektive Shadow-Map
  \begin{itemize*}
    \item adaptive schiefsymtetrische Projektion; nicht uniforme perspektive Shadow Map
  \end{itemize*}
  
  \subsection{ Zusammenfassung}
  \begin{itemize*}
    \item Transformation des Texturraums in den Bildraum der Darstellung:
    \item Verwendung unterschiedlicher geometrische Transformationen (z. B affin, perspektivisch, Env. Maps, etc.)
    \item Anwendung immer als inverse Transformation!
    \item Resampling + Rekonstruktion: Das transformierte Texturraster wird nach der Transformation durch das Bildraster neu abgetastet.
    \item Filter: Verhindern bzw. Abmildern von Aliasing-Effekten, verursacht durch Resampling.
    \item Lösung: Tiefpass-Filter vor der Transformation: Mipmapping, Anisotrope Filter.
    \item Beim Abtasten (Rekonstruktion):Trilineare Filterung in x, y, und k (Mip-Map-Stufe)
    \item Texturinhalt als Material, Beleuchtung, Geometrie interpretiert
  \end{itemize*}
  
  
  \section{Grafik Pipeline}
  \begin{itemize*}
    \item algorithmisches Konzept, sowie Realisierung der Grafikkartenhardware ist vergleichbar mit Fließband
    \item spezialisierte Arbeitsstationen (Spezialprozessoren)
    \item jedes geometrische Objekt durchläuft Arbeitsstationen sequenziell
    \item Arbeitsschritte können dadurch gleichzeitig auf verschiedenen Daten ausgeführt werden
  \end{itemize*}
  
  \subsection{Bestandteile}
  Programm API -> Treiber -> Vertex-Verarbeitung -> Primitivenbehandlung -> Rasterisierung \& Interpolation -> Fragment Verarbeitung -> Rasteroperation -> Bildspeicher
  
  \subsection{Allgemeines}
  \begin{itemize*}
    \item Anwendungsprogramm:
    \begin{itemize*}
      \item läuft auf der CPU,
      \item definiert Daten und Befehlsabfolge,
      \item greift dazu über das Grafik-API (Application Programming Interface, z. B. OpenGL, Direct3D) auf die Grafikkarte zu
    \end{itemize*}
    \item Treiber: übersetzt die Grafikbefehle des Programms in die Maschinensprache der speziellen Grafikhardware (Graphics Processing Unit / GPU, z.B. von nVidia, AMD oder Intel)
    \item Befehle und Daten werden über den Bus (z.B. PCI-Express) von der CPU auf die GPU übertragen
    \item OpenGL-Pipeline: Abarbeitung der Grafikbefehle auf der GPU
    \item Ausgabe des Bildspeichers auf dem Monitor
    \item Treiber schickt Daten/Befehle an die GPU (z. B. via PCIe -Bus)
    \item Funktionsausführung auf der GPU ist dann abhängig vom aktuellen Zustand (OpenGL State Machine bzw. den gewählten Shadern):z.B. vorher definierter Primitivtyp (hier GL Polygon), Transformation, Lichtquellen, Interpolationsart (z.B. Gouraud Shading vs. Flat Shading)
  \end{itemize*}
  
  Abarbeitungsreihenfolge auf der GPU:
  \begin{itemize*}
    \item Empfangen der Vertices in einer geordneten Sequenz.
    \item Vertexverarbeitung via Vertex Shader. Jeder Input-Vertex im Datenstrom wird in einen Output-Vertex transformiert und beleuchtet.
    \item Primitive culling (Verwerfen wenn nicht sichtbar) und clipping (Abschneiden der Polygone am Rand)
    \item Rasterkonvertierung (Polygon Filling) und Interpolation der Attributwerte (x-Koordinate, 1/z, R, G, B, Texturkoordinaten u/v, ...)
    \item Die Daten jedes Fragmentes (Pixel/Subpixel) wird mit einem Fragment Shader verarbeitet. Zu jedem Fragment gehört eine Anzahl Attribute.
    \item Per-Sample Operationen: Blending (Alpha-Blending bei Transparenz), Tiefen- und Stencil- Operationen ...
  \end{itemize*}
  
  
  \subsection{Vertex-Verarbeitung}
  \begin{itemize*}
    \item Transformationen: Modell-Transformation, Kamera-Transformation (Model View Matrix) → Matrixmultiplikationen → Skalarprodukt
    \item Beleuchtung (Lighting): Lichtquellen, diffuses \& spekuläres Material: (Gouraud Shading) Lambert, Phong-Modell → Skalarprodukt
    \item Skalarprodukte (Gleitkomma-Multiplikationen und Additionen) werden durch viele parallele Prozessoren auf der GPU effizient verarbeitet.
  \end{itemize*}
  
  %\subsection{Primitive & Primitivenbehandlung}
  %![Primitive; Quelle Computergrafik Vorlesung 2020/21](Assets/Computergrafik-Renderpipeline-primitive.png)
  
  \subsection{Rasterkonvertierung}
  \begin{itemize*}
    \item Edge Tables bereits erzeugt (Polygonsetup in Primitivenbeh.)
    \item Rasterkonvertierung/Interpolation entspricht der Scan-Line-Konvertierung (s. Polygonfüllalgoritmus), generiert Pixel (Fragments)
    \item Interpolation der x-Werte der Kanten (siehe left edge scan /bzw. right edge scan)
    \item pro Scan Line: inkrementiere x-Wert (left edge, right edge) (OpenGL behandelt nur konvexe Polygone/Dreiecke – d. h. immer 2 Kanten pro Bildzeile!)
    \item lineare Interpolation weiterer Attribute:
    \begin{itemize*}
      \item z (1/z)-Werte,
      \item RGB-Werte (Gouraud Shading),
      \item Texturkoordinaten u/v (affines Texturmapping),
      \item Normalen (Phong Shading)
    \end{itemize*}
    \item sehr wenige Ganzzahloperationen pro Pixel/Bildzeile
    \item Ausnahmen: z. B. perspektivische Texture Maps (FP-Division!)
  \end{itemize*}
  
  
  \subsection{Fragment-Verarbeitung}
  Weiterverarbeitung auf Basis der interpolierten Attribute im Fragment Shader
  
  Beispiel Phong-Shading: Berechnung des Phong-Beleuchtungsmodells auf Basis der vorher linear interpolierten Fragmentnormalen, -position und Materialdaten sowie der Daten der Lichtquellen und Kameraposition
  
  \subsection{Rasteroperationen}
  \begin{itemize*}
    \item Abschließende Auswahl/Zusammenfassung der berechneten Fragmentdaten (pro Pixel)
    \item Beispiel: nicht transparente Objekte, Übernahme der Farbwerte mit z-Position, welche am dichtesten an der Kamera ist (z-Buffer)
    \item Beispiel: transparente Objekte (z.B. Glashaus), lineares Blending zwischen schon existierenden Farbwerten und neuesten entsprechend der Transparenz
  \end{itemize*}
  
  \subsection{Performance}
  Einfaches Modell zur Bestimmung der Rechenzeit T:
  $T = a * \text{Anzahl Vertices} + b * \text{Anzahl Bildpixel}$ (a = Aufwand pro Vertex, b = Aufwand pro Pixel)
  
  \begin{itemize*}
    \item Grafikkarten geben ihre Performance an in:
    \begin{itemize*}
      \item  Anzahl Polygone / Sekunde (Polygone mit kleiner Pixelanzahl)
      \item Anzahl verarbeitete Pixel / Sekunde
      \item  z.B. ca. 100 Millionen Polygone/sec à 10 Pixel / Polygon (mit Texturen, tri-lineare Filterung, etc. mehrere Milliarden Pixel / s (Gouraud Shader) (Angaben: nVidia Geforce 6800 - Jahr 2005)
    \end{itemize*}
    \item Problem der Grafik-Pipeline: Flaschenhals! - Langsamste Operation hält Pipeline auf (bestimmt Durchsatz) → Zwei extreme Situationen:
    \begin{itemize*}
      \item  Vertex-limited: viele Vertices, kleine Polygone (wenige Pixel), einfache lineare Interpolation der Vertex-Attribute pro Fragment (kleines b )
      \item  Fill rate limited: anspruchsvolle Fragment-Shader (großes b), weniger dafür große Polygone (viele Pixel)
    \end{itemize*}
    \item Außerdem: Grafikspeicher-Zugriffe sind teuer (Latenz und Bandbreite beachten!) z.B. Auslesen gerenderter Bilder aus dem Grafikspeicher
    \item Eine für die Grafikkarte angegebene Performance (z. B. 100 Mio Polygone/sec bei G-Force 6800) ist nur unter unrealistisch günstigen Bedingungen zu erreichen.
    \begin{itemize*}
      \item  d. h. z.B. nicht 100 Mio. unterschiedliche Polygone mit 1 fps (wegen Speicherbandbreite für Vertexzugriffe)
      \item  auch nicht 10.000 Polygone mit 10.000 fps (da Framebuffer-Reset teuer)
      \item  Herstellerangaben gelten nur unter optimalen Bedingungen (z. B. 10 Pixel / projiziertem Polygon)!
      \item  realistisch (verschieden große Polygone) → ca. 1 Mio Polygone mit 10 fps (10 Mio Polygone/s) = 10\% der Peak Performance!
    \end{itemize*}
  \end{itemize*}
  
  $$\text{Durchsatz (fps)} \approx \text{Konst.} / \text{Polygonanzahl}$$
  \begin{itemize*}
    \item unter realitischem Durchsatz: Begrenzung durch Bildspeicher
    \item über realisitschem Durchsatz: Begrenzung durch Geometriespeicher
  \end{itemize*}
  
  %\subsection{Hardware-Architektur
  %![GPU Architektur](Assets/Computergrafik_GPU_Hardware.png)
  
  \section{Bildverarbeitung}
  \subsection{Operationen auf dem Bildraster}
  Problem der Vorwärtstransformation:
  \begin{itemize*}
    \item Farbwerte sitzen im Zielbild an nicht ganzzahligen Koordinaten, das Ausgabegerät benötigt aber Farbwerte in einem Raster (ganzzahlige Koordinaten)
    \item durch Runden können Löcher im Bild entstehen, einige Pixel werden u. U. mehrfach belegt
  \end{itemize*}
  
  %![Bildraster Skalieren](Assets/Computergrafik_Bildraster_skalieren.png)
  
  Problemdiskussion: 
  \begin{itemize*}
    \item 45° - Drehung eines 3x3 Pixel großen Quadrates $\rightarrow$ Den Koodinaten (-1,1) und (1,1) beinhalten 2 Pixel aus dem Original (0,2) ist kein Pixelzugeordnet!
    \item Runden: führt zu Ausfallartefakten, da bestimmte Zielbildpixel je nach Transformation nicht erreicht werden
    \item Betrachtung eines Bildes aus 2 Kamerapositionen (Stereo)
    \begin{itemize*}
      \item Bild aus verschiedenen Kameraperspektiven betrachtet.
      \item Beide Kameras sind auf den gleichen Punkt FP gerichtet.
      \item Die unterschiedlichen Pixel des Quellbildes werden an unterschiedliche Positionen in den beiden Zielbildern (jeweils Kamerabild in Kamerakoordinatensystem) abgebildet (Vorwärtstransformation).
      \item Störstrukturen bei Skalierung auf jeweils beiden Bildern
    \end{itemize*}
  \end{itemize*}
  
  Lösungs-Idee: Inverse Transformation
  \begin{itemize*}
    \item inverse Transformation, d.h. indirekte Methode
    \item da jedes Pixel im Zielbild B an der Position (k, l) Ausgangspunkt der Rechnung ist, bleibt keines unbelegt
    \item keine Löcher mehr!
    \item Problem: Auch das Quellbild A ist nur an ganzzahligen Rasterpunkten i,j gegeben. Wie ermittelt man A(x,y) aus den Pixeln A(i,j) im Umfeld von x,y? Wie groß muss das Umfeld sein? → Resamplingproblem (Wiederabtastung)
  \end{itemize*}
  
  Lösungsansatz: Rückwärtstransformation der Pixelkoordinaten
  \begin{itemize*}
    \item Inverse Transformation der Koordination vom Zielbild + Sampling im Originalbild
    \item Es entstehen zwar keine Lücken im Zielbild, aber durch Rundung nichtganzzahliger Pixelkoordinaten auf den nächstenganzzahligen Wert können dennoch Aliasing-Artefakte entstehen: $B(k.l)=A(h^{-1}(k,l)$
    \begin{itemize*}
      \item einzelne Pixel im Originalbild werden öfter gesampelt als andere
      \item einige Pixel im Originalbild werden ausgelassen!
    \end{itemize*}
  \end{itemize*}
  
  %![Rücktransformation I](Assets/Computergrafik_Rückwärtstransformation_Pixelkoordinaten.png)
  
  Rückwärtstransformation der Pixelkoordinaten mit Interpolation benachbarter Pixel:
  \begin{itemize*}
    \item Inverse Transformation der Koordination vom Zielbild + Sampling im Originalbild
    \item bei nicht ganzzahligen Pixelkoordinaten kann man zwischen den benachbarten Pixelwerten im Originalbild interpolieren (RGB-Werte) (Rekonstruktion eines genaueren Zwischenwertes / Antialiasing)
    \item dadurch werden die scharfen (aber ungenau positionierten Flächengrenzen) zwar unscharf. . .
    \item aber die wahrgenommenen Grenzen zwischen schwarzen und weißen Flächen können so zwischen den ganzzahligen Pixelwerten positioniert werden
    \item die empfundene Genauigkeit wird durch Antialiasing sogar erhöht!
  \end{itemize*}
  
  %![Rückwärtstransformation II](Assets/Computergrafik_Rückwärtstransformation_Interpolation.png)
  
  Rückwärtstransformation bei doppelter Auflösung des Zielbildes: Vergleich mit exakter Darstellung nur bei doppelter Auflösung möglich
  
  Verkleinern eines Bildes durch Skalierung
  \begin{itemize*}
    \item Inverse Transformation der Koordination vom Zielbild + Sampling im Originalbild
    \begin{itemize*}
      \item auch hier entstehen zwar keine Lücken im Zielbild beim Transformieren zusammenhängender Bilder
      \item aber beim Sampeln im Originalbild entstehen Aliasing-Artefakte:
      \item z.B. Auslassen jedes zweiten Pixels im Originalbild → Zielbild wird uniform weiß (oder schwarz)
    \end{itemize*}
    \item exakte Lösung wäre nur bei doppelter Auflösung möglich
    \item jedoch Auflösung im Zielbild begrenzt, gute Näherung muss gefunden werden
    \item Näherung durch Sampeln und Interpolation mehrerer Nachbarpixel führt zu möglicher Lösung
  \end{itemize*}
  
  
  Fazit:
  \begin{itemize*}
    \item Vorwärtstransformation:
    \begin{itemize*}
      \item gesuchte Farbwerte im Zielbild liegen nicht immer an ganzzahligen Koordinaten
      \item durch Rundung können Lücken im Zielbild entstehen
    \end{itemize*}
    \item Rückwärtstransformation:
    \begin{itemize*}
      \item es entstehen keine Lücken im Zielbild, dennoch können (Sampling) Artefakte (Aliasing) auftreten
      \item diese Artefakte können durch Interpolation mehrerer Pixel teilweise abmildert werden
    \end{itemize*}
  \end{itemize*}
  
  
  \subsection{Frequenzraum}
  Um das Thema Sampling und Rekonstruktion und Aliasing-Artefakte besser verstehen zu können und um eine möglichst optimale (und theoretisch begründbare) Lösung zu finden machen wir einen Ausflug in die Signaltheorie und digitale Filter.
  Zur Beschreibung der Filtereigenschaften wird der Frequenzraum des Bildes eingeführt.
  Def.: Frequenz ist die Wiederholrate eines periodischen Signals. Bei zeitabhängigen Signalen S(t) gibt die Frequenz an, wie oft sich das Signal pro Sekunde wiederholt: $f(Hertz)=\frac{1}{t}$
  
  Ein Bild ist im zweidimensionalen Ortsraum definiert:
  \begin{itemize*}
    \item Farb-/Helligkeitswert als Funktion des Ortes W(x,y)
    \item Bei ortsabhängigen Signalen (z.B. Bildmustern) ist mit Frequenz gemeint, nach welcher Distanz (in Pixeln gemessen) sich das Muster im Bild wiederholt.
    \item Die Umwandlung vom Ortsraum in den Frequenzraum (und umgekehrt) geschieht durch eine Fourier-Transformation.
    \begin{itemize*}
      \item damit kann ein Bild im Frequenzraum f definiert werden
      \item $S(f)$ wird Spektrum genannt
    \end{itemize*}
  \end{itemize*}
  
  %![Frequenzraum](Assets/Computergrafik_Frequenzraum_Signal.png)
  
  Beispiel: 2D-Spektrum eines Schachbrettmusters
  \begin{itemize*}
    \item Kleinstes auf einem Pixelraster darstellbares Muster hat Durchmesser von 2 Pixel (d.h. 0,5 Wiederholungen pro Pixel)
    \item Höchste darstellbare Frequenz $f_x = f_y = 0,5 \text{Pixel}^{-1}$
    \item Diese Frequenz nennt man Nyquist-Frequenz!
  \end{itemize*}
  
  Bildraster als P-dimensionaler Vektorraum:
  \begin{itemize*}
    \item Das diskrete Grauwertbild $F (i* \delta x, j * \delta y )$ habe M Spalten und N Zeilen
    \item $P = M * N$ (=Anzahl Bildpunkte) ist damit die Dimension des Primärdatenraumes des Bildes
    \item Wir stellen uns bewusst das Bild aus Punkten zusammengesetzt vor, d.h.
    \begin{itemize*}
      \item wir können von $M * N$ Basisbildern der Dimension $M * N$ ausgehen, in denen jeweils nur ein Pixel den Wert 1 (weiß) besitzt (alle anderen Pixel Schwarz = 0)
      \item diese Basisbilder sind damit alle orthonormal → Wichtungsfaktoren durch inneres Produkt!
      \item sie ergeben in der grauwertgewichteten Summe das diskrete Bild F
    \end{itemize*}
  \end{itemize*}
  
  %![Frequenzraum II](Assets/Computergrafik_Frequenzraum_diskretes_Bild.png)
  
  Vektoroperationen im Bildraum: Mit der mathematischen Definition eines Rasterbildes als Vektor in einem hochdimensionalen Vektorraum, lassen sich viele Bildoperationen als Vektoroperatoren elegant darstellen
  \begin{itemize*}
    \item z.B. Skalarprodukte zwischen zwei Bildern (Linearkombination lineare Unabhängigkeit)
    \item Basistransformation: Ganze Bilder (als Vektoren) dienen als Basis eines transformierten Bildraumes.
    \item Die neuen Basisvektoren müssen linear unanhängig sein und idealerweise orthonormal zueinander stehen.
    \item Eine Basistransformation entspricht einer "Drehung" des Vektorraumes um den Nullpunkt.
  \end{itemize*}
  
  \paragraph{Transformation}
  Jedes Pixel im gedrehten Raum entspricht einem Bild im Ursprungs-Raum.
  Jedes Bild ist eine Linearkombination der Basisvektoren, entspricht also einer gewichteten Addition von Bildern im Ursprungsraum.
  
  %![Transformation](Assets/Computergrafik_Frequenzraum_Transformation.png)
  
  4 neue Basisvektoren $B_i$ (2 x 2 Pixel), welche unterschiedliche Frequenzen darstellen
  
  %![Basisvektoren](Assets/Computergrafik_Transformation_Basisvektoren.png)
  %(Weiß=+1; Schwarz=-1; Grau=0)
  
  Die 4 Basisvektoren stehen orthonormal zueinander. Test mittels paarweisen Skalar-produkten: $B_iB_k=\begin{cases}1 \text{ falls } i=k\\ 0 \text{ sonst }\end{cases}$.
  Jedes einzelne Pixel aber auch jedes Bild kann als Linearkombination aus 4 Basisvektoren $B_1$ bis $B_4$ konstruiert werden: $P=a*B_1+b*B_2+c*B_3+d*B_4$
  \begin{itemize*}
    \item Gleichungssystem: 4 Gleichungen für die Koeffizienten a,b,c,d
    \item Berechnung der Frequenzanteile a bis d über Lösung des Gleichungssystems oder Projektion von P auf $B_1$ bis $B_4$ (mittels Skalarprodukt): $a=P*B_1$
  \end{itemize*}
  %![Basisvektoren II](Assets/Computergrafik_Basisvektor_Linearkombination.png)
  
  Bsp: $a=P*B_1 = <-1, 1, -1, -1><\frac{1}{2}, \frac{1}{2}, \frac{1}{2}, \frac{1}{2}> = -1*\frac{1}{2}+1*\frac{1}{2}-1*\frac{1}{2}-1*\frac{1}{2} = -1$
  
  
  \paragraph{DCT - Discrete Cosinus Transformation}
  \begin{itemize*}
    \item Spezielle Basistransformation: Cosinus Transformation
    \item Jedes Pixel im Cosinus Raum entspricht einem Bild mit Cosinus-Funktionen verschiedener Frequenzen oder Phasen (in x- oder y-Richtung)
    \begin{itemize*}
      \item Links oben: Frequenz = Null (Durchschnittswert des Bildes)
      \item Rechts unten: Anteil der höchsten Frequenz
    \end{itemize*}
    \item Der Cosinus Raum bildet ein Orthonormalsystem
    \item ein Pixelbild im Ursprungsraum lässt sich zusammensetzen als gewichtete Addition von Bildern mit unterschiedlichen Frequenzen → Spektralzerlegung
    \item Ähnlich funktioniert die Fouriertransformation (Sinus und Cosinustransformation)
  \end{itemize*}
  
  %![DCT](Assets/Computergrafik_DCT.png)
  
  \paragraph{Fouriertransformation}
  \begin{itemize*}
    \item Grundidee: jede beliebige periodische Funktion lässt sich darstellen als Summe von $\sin$ und $\cos$ Funktionen unterschiedlicher Frequenzen
    \item Transformation: verändert eine Funktion nicht, sondern stellt sie nur anders dar
    \item Transformation ist umkehrbar: somit existiert auch eine inverse Fourier-Transformation
    \item Hochpassfilter: ausblenden der tiefen Frequenzen im Frequenzraum
    %![Hochpassfilter](Assets/Computergrafik_Fourier_Hochpass.png)
    \item Tiefpassfilter: ausblenden der hohen Frequenzen im Frequenzraum
    %![Tiefpassfilter](Assets/Computergrafik_Fourier_Tiefpass.png)
  \end{itemize*}
  
  
  \paragraph{Signalrekonstruktion}
  \begin{itemize*}
    \item die Abtastfrequenz viel höher als die Signalfrequenz im Original
    \item Konkret: Die Signalfrequenz liegt unter der halben Abtastfrequenz, der sogenannten Nyquistfrequenz
    \item Samplingtheorem von Nyquist:
    \begin{itemize*}
      \item Signale unterhalb der Nyquistfrequenz der Samples können rekonstruiert werden
      \item andererseits: Signale oberhalb der Nyquistfrequenz können nicht rekonstruiert werden
      \item stattdessen entsteht ein völlig fremdes Signal, welches mit dem Original offensichtlich nichts mehr zu tun hat
      \item Aliasing-Effekt (entsteht z. B. auch bei digitalen Tonaufnahmen von hohen Frequenzen, wenn die Samplingrate für diese Frequenzen zu niedrig ist)
    \end{itemize*}
  \end{itemize*}
  
  \paragraph{Anitaliasing}
  \begin{itemize*}
    \item Aliasing bei Bildern entsteht u.a. bei der Kameraaufnahme von diskreten, digitalen Bildern, wenn das Bild in Bezug auf das Abtastraster zu hohe Frequenzen enthält (Verletzung des Abtasttheorems).
    \item die höchste zulässige Frequenz wird als Nyquistfrequenz bezeichnet
    \begin{itemize*}
      \item sie ist gleich der halben Abtastfrequenz:$K_{x,Nyqu}=\frac{1}{2*\delta x}, x = Pixelabstand$
      \item zum besseren Verständnis des Grundproblems noch mal drei Beispiele nebeneinander:
      %![Beispiel](Assets/Computergrafik_Antialiasing_Nyquist.png)
      \item Nachträgliches Filtern kann das Aliasing nicht mehr beseitigen.
    \end{itemize*}
    \item Rekonstruktion eines Signals mittels Interpolation durch Erzeugen weiterer Samples zwischen den gemessenen Samples mittels eines Interpolationsalgorithmus (Supersampling)
    \item z.B. durch polynomiale Interpolation (mehrere Nachbarsamples)
    \item Dennoch entsteht ein etwas gestörtes Signal (hier nicht harmonische Verzerrung / Modulation)
    \item → Aliasing-Effekt, allerdings in abgemildertem Umfang
  \end{itemize*}
  
  Bei der eingangs vorgeschlagenen Rückwärtstransformation (vom Zielbild zurück ins Originalbild) ist die Samplingrate durch das Zielbild bestimmt (d.h. ein Sample pro Pixel im Zielbild). 
  Wir können damit das Aliasing Phänomen besser erklären: Bei der Verkleinerung um ein Faktor 2 ist die Samplingrate im Originalbild nur halb so groß wie die
  Nyquistfrequenz des Originalbildes! ($0,25 Pixel^{-1}$ statt $0,5 Pixel^{-1}$).
  Beim Sampeln mit zu niedriger Samplingrate (unterhalb der Nyquistfrequenz) kann das Originalbild nicht mehr rekonstruiert werden. Es entstehen Aliasingeffekte: Das Zielbild wird  uniform weiß (oder schwarz, wenn Original um ein Pixel verschoben wird).
  Der Begriff der Nyquistfrequenz erklärt das bekannte Phänomen und verweist auf mögliche Lösungen.
  
  Aliasing kann bei der Ausgabe von Graphiken oder Bildinhalten auf Ausgabegeräten entstehen, denn dieser Prozess ist in der Regel mit einer Rasterung (Rasterisation) verbunden.
  \begin{itemize*}
    \item Dies betrifft die Computergraphik vielerorts und steht deshalb hier im Mittelpunkt!
    \item Aliasing entsteht in der Computergraphik insbesondere dann, wenn die Originale in viel höherer Auflösung vorliegen als das Raster des Ausgabegerätes (z.B. hochaufgelöste Bilder, feinste Texturen, aber auch beim Raytracing kleinster Objekte (Strahlverfolgung = Sampling), etc.)
    \item Aliasing kann auch bei digitalen Fotografien von kleinteiligen (analogen) Mustern entstehen.
    \item Da sich Aliasing-Artefakte nicht nachträglich beseitigen lassen, kann Anti-Aliasing nicht erst dann ansetzen, wenn das Bild bereits fertig gerendert ist.
    \item Beachte: Tiefpassfilterung muss deshalb immer vor dem Resampling angewendet werden.
  \end{itemize*}
  
  \paragraph{Anwendung Tiefpassfilter}
  Um Bild (durch **Koordinatentransformation**) korrekt rekonstruieren zu können, müssen wir zuerst im Originalbild die hohen Frequenzen, die oberhalb der Nyquistfrequenz des Zielbildes liegen, eliminieren.
  
  Um Bild (durch **inverse Transformation**) korrekt rekonstruieren zu können müssen wir:
  \begin{itemize*}
    \item Zuerst im Originalbild die hohen Frequenzen, die oberhalb der Samplingrate des Zielbildes transformiert in das Originalbild liegen, eliminieren.
    \item Danach Sampling des gefilterten Originalbildes durch inverse Transformation jedes Pixels im Zielbild
  \end{itemize*}
  
  → Die höchsten Frequenzen des Originalbildes können aufgrund der zu geringen Auflösung im Zielbild ohnehin nicht dargestellt werden. Dieser Ansatz findet die beste Lösung unter den gegebenen Umständen. 
  
  Achtung! Reihenfolge ist wichtig: Wenn man zuerst sampelt und dann das Zielbild filtert, lässt sich u.U. die Originalinformation (wenn dort Frequenzen oberhalb der Nyquistfrequenz enthalten sind) nicht mehr rekonstruieren!
  
  \subsection{Rekonstruktionsfilter}
  Die oben beschriebene Filterung im Frequenzraum erfordert eine Fouriertransformation des Bildes in den Frequenzraum. Nach Eliminierung der hohen Frequenzen ist die Rücktransformation erforderlich. Dies ist noch sehr aufwendig!
  
  Das selbe Ergebnis können wir einfacher erreichen, indem wir die Filterfunktion vom Frequenzraum in den Ortsraum transformieren (durch eine inverse Fouriertransformation) und dann direkt im Ortsraum anwenden:
  \begin{itemize*}
    \item Box-Filter = ideales Tiefpass-Filter in Frequenzraum; eliminiert alle Frequenzen oberhalb
    \item Boxfilter im FR = sinc-Funktion im Ortsraum (Fouriertransformierte der Rechtecksf.) $sinc(x)=\frac{sin(x)}{x}$
  \end{itemize*}
  
  Rekonstruktion von Zwischenpixelwerten durch Interpolation benachbarter Pixel:
  \begin{itemize*}
    \item Inverse Transformation der Koordination vom Zielbild + Sampling im Originalbild
    \item Bei einer Vergrößerung findet hierbei eine Überabtastung statt (d. h. das Signal im Originalbild liegt unter der halben Nyquistfrequenz der Samplingrate des Zielbildes)
    \item Zur genauen Rekonstruktion von Zwischenwerten kann man interpolieren, d.h. ein gewichtetes Mittel zwischen Werten der benachbarten Pixel im Originalbild berechnen
    \item Dadurch werden die scharfen (aber ungenau positionierten Flächengrenzen) zwar unscharf... Aber die wahrgenommene Genauigkeit nimmt zu → Antialiasing
    \item Zur Gewichtung können ebenfalls Filterfunktionen im Ortsraum verwendet werden – Cut-off-Frequenz = Nyquistfrequenz im Originalbild (z. B. lineare Interpolation oder Nearest Neighbor, Sinc Funktion, etc.)
  \end{itemize*}
  
  \paragraph{Exakte Interpolation}
  Rekonstruktionsfilter (supersampling) per Sinc-Funktion (Exakte Interpolation):
  \begin{itemize*}
    \item Inverse Transformation: $B(k, l) = A(h^{-1} \{k, l\}) = A(x, y )$
    \item Interpolationsansatz 1 für das Resampling:
    \begin{itemize*}
      \item gewichtete Überlagerung der Abtastwerte aus der lokalen Umgebung des Quellbildes. Die Gewichte werden durch Interpolationsfunktionen festgelegt. Die Interpolations-funktionen bestimmen die Qualität des Zielbildes (Störungen, Artefakte).
      \item $A(x,y)=\sum_{i=-\infty}^{\infty}\sum_{j=-\infty}^{\infty}A(i,j) * f_{int}(x-i, y-j)$
      \item Filterkern $f_{int}$ ist zentriert um das Pixel $A(x, y)$
      \item Filter ist selbst auch als Rasterbild definiert
    \end{itemize*}
  \end{itemize*}
  
  Anwendung der Filter auf Bildinformationen: 
  $$G(x,y)=\sum_{m=-size}^{size} \sum_{n=-size}^{size} F(x+m, y+n) * H(m,n)$$
  mit Ausgabebild $G(x,y)$, Eingabebild $F(x+m,y+n)$ und Filterkern $H(m,n)$
  
  Beispiel 3x3 Spalttiefpass (Boxfilter im Ortsraum):
  \begin{itemize*}
    \item $m=(-1,1), n=(-1,1)$
    \item $H=\frac{1}{9} \begin{pmatrix} 1&1&1\\ 1&1&1 \\ 1&1&1 \end{pmatrix}$
    \item einfache Mittelwertbildung der Nachbarpixel → unscharfes Bild und hochfrequente Artefakte
    \item Faltungsoperatoren zur Tiefpassfilterung → Beispiel Rauschunterdrückung
  \end{itemize*}
  
  Beispiel Filterfern: 5x5 Binominalfilter
  
  $H_{5x5} =\frac{1}{256} * \begin{pmatrix} 1\\4\\6\\4\\1 \end{pmatrix} \begin{pmatrix} 1&4&6&4&1 \end{pmatrix}=\frac{1}{256} \begin{pmatrix} 1&4&6&4&1\\ 4&16&24&16&4\\ 6&24&36&24&6\\ 4&16&24&16&4\\ 1&4&6&4&1 \end{pmatrix}$
  
  Interpolatiponsansatz 1 / Methode 1: Exakte Interpolation
  \begin{itemize*}
    \item Hinreichend bandbegrenzte Bilder lassen sich theoretisch exakt interpolieren: Multiplikation des Quellbild-spektrum mit Rechtecktiefpass im Frequenzbereich
    \item Im Ortsbereich führt das auf eine diskrete Faltung mit der sinc-Funktion.
    \item In der Theorie gibt es keinerlei Störungen / keine Artefakte.
    \item Praxisproblem: die sinc-Funktion ist unendlich ausgedehnt!
  \end{itemize*}
  
  Sinc-Filter: Das Sinc-Filter ist zwar theoretisch ideal (scharfe Grenze im Frequenzraum) doch gilt dies nur bei gleichmäßiger Abtastung über der Nyquist-Frequenz, was in der Computergrafik meist nicht realisierbar ist. Besonders bei Kanten führt der Sinc-Filter zu starken Ringing-Artefakten. 
  Die Sinc-Funktion einen unendlichen Träger, sodass zur Berechnung des Farbwerts eines Pixels alle Abtastwerte des Bildes herangezogen werden müssen. Ein einfaches Abschneiden der Sinc-Funktion (Lanczos-Filter) führt zu schlechten Ergebnissen.
  
  \begin{itemize*}
    \item Box-Filter
    \begin{itemize*}
      \item Alle Abtastwerte innerhalb eines um das Pixel gelegte Quadrat (meist mit der Kantenlänge von einem Pixelabstand) haben die gleiche Gewichtung: → Mittelwertbildung
      \item Das Box-Filter liefert im Allgemeinen schlechte Ergebnisse, da seine Fourier-Transformierte eine Sinc-Funktion ist, die den gewünschten Frequenzbereich nur schlecht isoliert
    \end{itemize*}
    
    \item Kegel-Filter
    \begin{itemize*}
      \item Beim Kegel-Filter fällt die Gewichtung mit zunehmender Distanz zum Pixel linear ab.
      \item Es liefert etwas bessere Ergebnisse als das Box-Filter
      \item Artefakte sind noch vorhanden, aber deutlich abgeschwächt!
    \end{itemize*}
    
    \item Gauß-Filter
    \begin{itemize*}
      \item Beim Gauß-Filter wird zur Rekonstruktion eine Gauß-Funktion verwendet. Die Fouriertransformierte einer Gauß-Funktion ist wieder eine Gauß-Funktion.
      \item Dieser Filter führt zu Unschärfe (höhere Frequenzen, auch unterhalb der Nyquistfrequenz werden zu stark abgeschwächt),
      \item dafür werden aber Aliasing-Effekte sehr gut unterdrückt
    \end{itemize*}
    
    \item Mitchell-Netravali-Filter
    \begin{itemize*}
      \item sind stückweise kubische Filter mit vier Pixel breiten Trägern.
      \item Sie sind durch zwei freie Parameter änderbar und wurden speziell dafür entworfen, die aus Rekonstruktionsfiltern resultierenden Artefakte zu untersuchen.
      \item Bei geeigneter Parameterwahl liefern die Filter einen guten Kompromiss zwischen Unschärfe, Anisotropie und Ringing.
      \item Die Mitchell-Netravali-Filter werden auch als bikubische Filter bezeichnet, z. B. kubische B-Splines, o. Ä.
    \end{itemize*}
  \end{itemize*}
  
  \paragraph{Nearest Neighbour}
  \begin{itemize*}
    \item Einfache Übernahme des geometrisch nächsten Nachbarn aus dem Quellbild.
    \item Entspricht der Faltung mit einem Rechteck der Breite$\delta x$ im Ortsbereich, d.h. Multiplikation des periodifizierten Bildspektrums mit einer Sinc-Funktion im Frequenzbereich.
    \item Ergebnis: Massive Störungen (Artefakte) durch skalierte, z.T. phasengespiegelte Reste von periodifizierten Frequenzanteilen. Verunschärfungen halten sich in Grenzen, da die entsprechende sinc-Funktion bei der Nyquistfrequenz noch nicht wesentlich abgefallen ist. Die unsymmetrische Operation führt zu frequenzabhängigen, örtlichen Verschiebungen.
  \end{itemize*}
  
  \paragraph{Bilinearer Interpolation}
  \begin{itemize*}
    \item Entspricht der Faltung mit einem Dreieck der Breite $2*\delta x$ im Ortsbereich, d.h. Multiplikation des periodifizierten Bildspektrums mit einer $sinc^2$-Funktion im Frequenzbereich.
    \item Reduziertes Aliasing / Artefakte durch schnelleren Abfall der $sinc^2$-Funktion gegenüber sinc, merkliche Verunschärfung durch stärkeren Abfall bei der Nyquistfrequenz. Außermittige Interpolation führt zu frequenzabhängigen örtlichen Verschiebungen (Achtung bei Messanwendungen).
  \end{itemize*}
  
  \paragraph{Weitere Filter}
  \begin{itemize*}
    \item Filter zur Hoch- bzw. Bandpassfilterung:
    \item Anwendung: z.B. Kantenextraktion
    \item Sobelgradient: $H_{xS} =\begin{pmatrix} 1&0&-1\\ 2&0&-2\\ 1&0&-1\end{pmatrix}, H_{yS}=\begin{pmatrix} 1&2&1\\ 0&0&0\\ -1&-2&-1 \end{pmatrix}$
    \item Differenzbildung (Ableitung) → hohe Frequenzen werden verstärkt!
    \item im Gegensatz dazu sind Tiefpassfilter Integralfilter = gewichtete Summe der Nachbarpixel
  \end{itemize*}
  
  
\end{multicols}
\end{document}