\documentclass[a4paper,12pt,titlepage]{scrartcl}
\usepackage[sc]{mathpazo} % Schrift - wie Funcky und in PDF zu Fonts beschrieben
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a-1b]{pdfx}
\usepackage[ngerman]{babel}
\usepackage[amssymb]{SIunits} 
\usepackage{graphicx} 
\usepackage{subfigure}                         
\usepackage{float}
\usepackage[iso,german]{isodate} %his package provides commands to switch between different date formats
\usepackage{hyperref}
\usepackage{listings}

\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}
%Abstand zwischen Absätzen, Zeilenabstände
\voffset26pt 
\parskip6pt
%\parindent1cm  %Rückt erste Zeile eines neuen Absatzes ein
\usepackage{setspace}
\onehalfspacing

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

%Code listing style named "mystyle"
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},   
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}
%"mystyle" code listing set
\lstset{style=mystyle}

\begin{document}
\pagenumbering{roman}
\titlehead
{
    \small
    {
        Technische Universität Ilmenau\\
        Fakulät IA\\
        Fachgebiet Rechnerarchitektur\\

        Praktikum Rechnerarchitektur 1\\
        WS 2021/22}
}

\title {Versuchsprotokoll}
\subtitle{Versuche zur x86-Assemblerprogrammierung}
\author{}
\date{16.11.2021\\*[60pt]}
\maketitle  %Erstellt das Titelblatt wie oben definiert

%Einstellungen zur Kopf- und Fußzeile
\pagestyle{fancy}
\fancyhead[R]{Praktikumsbericht: RA1}
\pagenumbering{arabic}
\newpage

\section*{A1: Lauflicht}
Versuchsaufbau anhand einfacher Assemblerprogramme. Benutze parallele digitale Ein- und Ausgabebaugruppen, die mit den LED-Reihen, der Tasten- und der Schalterreihe sowie den Sieben-Segment-Anzeigen verbunden sind.
\subsection*{Grundaufgabe a: Funktionen ermitteln}

\begin{lstlisting}
    ; Programmbereich:
    anf:    MOV   EDX,400000H  ;Groessee der Verzoegerung
            MOV   [verzoe],EDX ;Verzoegerung speichern
    
    m1:     MOV   EDI,10    ;EDI=10
            MOV   ESI,OFFSET ziff   ;Adresse von ziff in ESI
    
    m2:     MOV   AL,[ESI+EDI-1]    ;AL=ziff+9
            OUT   0B0H,AL   ;SiebenSegment schreibt AL
            CALL  zeit      ;warten
            DEC   EDI       ;EDI=EDI-1
            JNZ   m2        ;if(EDI!=0) goto m2
    
            MOV   AL,0FFH   ;AL=255 (dec)
    m3:     OUT   5CH,AL    ;LED Reihe links schreiben
            NOT   AL        ;AL negieren
            OUT   5DH,AL    ;LED Reihe rechts schreiben
            CALL  zeit      ;warten
            MOV   BL,AL     ;Inhalt von AL wird noch gebraucht
            IN    AL,59H    ;Tastenreihe rechts lesen auf AL
            BT    EAX,7     ;Bit 7 von EAX in Carry Flag
            MOV   AL,BL     ;AL bekommt alten Wert zurueck
            JC    m1        ;if(m1==0) goto m1
            JMP   m3        ;goto m3 (Loop)
    
    ;zeit ist ein Unterprogramm, welches nur Zeit verbrauchen soll:
    zeit:   MOV   ECX,[verzoe] ;Lade wartezeit
    z1:     DEC   ECX       ;ECX=ECX-1
            JNZ   z1        ;if(ECX!=0) goto z1
            RET             ;zurueck zum Hauptprogramm
    
    ; Datenbereich:
    verzoe  DD    ?         ;Eine Speicherzelle (Doppelwort)
    ziff    DB    3FH,03H,6DH,67H,53H,76H,7EH,23H,7FH,77H
    \end{lstlisting}
    
    \begin{description}
        \item[anf] setzt die Länge der Wartezeit
        \item[m1] Lädt Register
        \item[m2] Zählt auf Sieben Segment Anzeige
        \item[m3] schreibt auf LED Reihe links und invertierend rechts
        \item[zeit] Verbraucht Zeit nach "verzoe"     
    \end{description}

\subsection*{Grundaufgabe b}
\subsubsection*{einfaches Lauflicht}
auf der rechten LED-Reihe soll ein sichtbarer Lichtpunkt von links nach rechts laufen und immer wieder von links beginnen

\begin{lstlisting}
anf:    MOV     EDX,400000H
        MOV     [verzoe],EDX

        MOV     AL, 80H     ;Startwert fuer LED Reihe
lauf:   OUT     5CH, AL     ;Wert auf LED Reihe schreiben
        CALL    zeit        ;warten
        ROR     AL, 1       ;Bits um 1 nach rechts 
        JMP     lauf        ;Schleife wiederholen

zeit:   MOV     ECX,[verzoe]
z1:     DEC     ECX
        JNZ     z1
        RET
\end{lstlisting}

\subsubsection*{Lauflicht mit Geschwindigkeitsumschalter}
das Lauflicht soll durch den linken Schalter zwischen "schnell" (Schalter oben) und "langsam" (Schalter unten) umschalten

\begin{lstlisting}
anf:    MOV     Al, 80H

lauf:   MOV     EDX, 400000H    ; Wert fuer "langsam"
        MOV     [verzoe], EDX   ;"langsam" in Speicher
        OUT     5CH, AL         ;LED Reihe schreiben
        MOV     BL, AL          ;AL speichern
        IN      AL, 58H         ;Schalter einlesen
        BT      AL, 7           ;7. Bit von AL in Carry Flag
        JNC     langsam         ;Carry Flag = 0, schalter unten
        MOV     EDX, 200000H    ; Wert fuer "schnell"
        MOV     [verzoe], EDX   ;"schnell" in Speicher
        CMC                     ;Carry Flag umschalten (0)

langsam: CALL   zeit            ;warten
        MOV     AL, BL          ;AL aus speicher zurueck
        ROR     AL,1            ;Bits um 1 nach rechts
        JMP     anf             ;Schleife wiederholen

zeit:   MOV     ECX,[verzoe]
z1:     DEC     ECX
        JNZ     z1
        RET
\end{lstlisting}

\subsubsection*{Lauflicht verändert Richtung}
zusätzlich zum oben implementierten soll die Bewegungsrichtung des Lichtpunktes durch den rechten Schalter der Schalterreihe zwischen "nach links" und "nach rechts" wechseln.

\begin{lstlisting}
anf:    MOV     Al, 80H
lauf:   MOV     EDX, 400000H    ; Wert fuer "langsam"
        MOV     [verzoe], EDX   ;"langsam" in Speicher
        OUT     5CH, AL         ;LED Reihe schreiben
        MOV     BL, AL          ;AL speichern
        IN      AL, 58H         ;Schalter einlesen
        BT      AL, 7           ;7. Bit von AL in Carry Flag
        JNC     langsam         ;Carry Flag = 0, Schalter unten
        MOV     EDX, 200000H    ; Wert fuer "schnell"
        MOV     [verzoe], EDX   ;"schnell" in Speicher
        CMC                     ;Carry Flag umschalten
langsam: CALL   zeit            ;warten
        MOV     AL, BL          ;AL aus speicher zurueck
        BT      AL, 0           ;0. Bit von AL in Carry Flag
        JNC     rechts          ;Carry Flag = 1; Schalter oben 
        ROL     AL,1            ;Bits um 1 nach links
        CMC                     ;Carry Flag umschalten (0)
        JMP     anf             ;Schleife wiederholen
rechts: ROR     AL, 1           ;Bits um 1 nach rechts
        JMP     anf             ;Schleife wiederholen
zeit:   MOV     ECX,[verzoe]
z1:     DEC     ECX
        JNZ     z1
        RET
\end{lstlisting}


\subsubsection*{Lauflicht mit Invertierung}
durch drücken einer beliebigen Taste der blauen Tastenreihe wird die Anzeige invertiert, d.h. der Lichtpunkt ist dunkel etc. Invertierung nur solange die Taste gedrückt wird.
\begin{lstlisting}
anf:    MOV     Al, 80H
lauf:   MOV     EDX, 400000H    ; Wert fuer "langsam"
        MOV     [verzoe], EDX   ;"langsam" in Speicher
        MOV     BL, AL          ;Kopie von AL anlegen
        IN      AL, 59H         ;Tastenreihe einlesen
        AND     AL, FFH         ;UND Operation mit FF
        JZ      nopress         ;kein Schalter gedrueckt
        NOT     BL              ;BL invertieren
        MOV     AL, BL          ;AL ueberschreiben
nopress: OUT    5CH, AL         ;LED Reihe schreiben
        IN      AL, 58H         ;Schalter einlesen
        BT      AL, 7           ;7. Bit von AL in Carry Flag
        JNC     langsam         ;Carry Flag = 0, Schalter unten
        MOV     EDX, 200000H    ; Wert fuer "schnell"
        MOV     [verzoe], EDX   ;"schnell" in Speicher
        CMC                     ;Carry Flag umschalten
langsam: CALL   zeit            ;warten
        MOV     AL, BL          ;AL aus speicher zurueck
        BT      AL, 0           ;0. Bit von AL in Carry Flag
        JNC     rechts          ;Carry Flag = 1; Schalter oben
        ROL     AL,1            ;Bits um 1 nach links
        CMC                     ;Carry Flag umschalten (0)
        JMP     anf             ;Schleife wiederholen
rechts: ROR     AL, 1           ;Bits um 1 nach rechts
        JMP     anf             ;Schleife wiederholen
zeit:   MOV     ECX,[verzoe]
z1:     DEC     ECX
        JNZ     z1
        RET
\end{lstlisting}

\subsection*{Zusatzaufgabe}
Erweiterungen des Programms nach eigenen Ideen:
\begin{itemize}
    \item symetrische LED Reihe zur Mitte
    \item Sieben Segment zählt 9 Schritte mit 
\end{itemize}
\begin{lstlisting}
anf:    MOV     Al, 80H
        MOV     EDI, 0 
        MOV     ESI, OFFSET ziff
lauf:   MOV     EDX, 400000H    ; Wert fuer "langsam"
        MOV     [verzoe], EDX   ;"langsam" in Speicher
        MOV     BL, AL          ;Kopie von AL anlegen
        IN      AL, 59H         ;Tastenreihe einlesen
        AND     AL, FFH         ;UND Operation mit FF
        JZ      nopress         ;kein Schalter gedrueckt
        NOT     BL              ;BL invertieren
        MOV     AL, BL          ;AL ueberschreiben
nopress: OUT    5CH,AL           ;LED Reihe links schreiben
        NOT     AL              ;AL negieren
        OUT     5DH,AL          ;LED Reihe rechts schreiben
        MOV     BH,[ESI+EDI-1]  ;Sieben Segment berechnen
        OUT     0B0H,BH         ;Sieben Segment schreiben
        DEC     EDI             ;Sieben Segment runterzaehlen
        JZ      timer           ;Timer auf 0 setzen
        IN      AL, 58H         ;Schalter einlesen
        BT      AL, 7           ;7. Bit von AL in Carry Flag
        JNC     langsam         ;Carry Flag = 0, Schalter unten
        MOV     EDX, 200000H    ; Wert fuer "schnell"
        MOV     [verzoe], EDX   ;"schnell" in Speicher
        CMC                     ;Carry Flag umschalten
langsam: CALL   zeit            ;warten
        MOV     AL, BL          ;AL aus speicher zurueck
        BT      AL, 0           ;0. Bit von AL in Carry Flag
        JNC     rechts          ;Carry Flag = 1; Schalter oben
        ROL     AL,1            ;Bits um 1 nach links
        CMC                     ;Carry Flag umschalten (0)
        JMP     anf             ;Schleife wiederholen
rechts: ROR     AL, 1           ;Bits um 1 nach rechts
        JMP     anf             ;Schleife wiederholen
timer:  MOV     BH, 0FFH
        RET 
zeit:   MOV     ECX,[verzoe]
z1:     DEC     ECX
        JNZ     z1
        RET
\end{lstlisting}

\section*{A2: Timerbaustein}
Arbeite mit einem programmierbaren Interfacebaustein, der über eigene Register angesprochen wird. Als Beispiel dient ein Programmierbarer Intervalltimer (PIT, auch als „Zähler-Zeitgeber-Baustein“ oder „Timerbaustein“ bezeichnet) vom Typ 8254.

\begin{center}
    \begin{tabular}{| l | c | c | c | c | c | c | c | c | }
            \hline
            \multicolumn{9}{|c|}{Frequenzen der C-Dur Tonleiter}\\
            \hline
            \hline
            Ton   & c'    & d'    & e'    & f'    & g'    & a'    & h'    & c''   \\\hline
            f(Hz) & 261,6 & 293,7 & 329,6 & 349,2 & 392,0 & 440,0 & 493,9 & 523,2 \\\hline
            Zählkonstante & 7662 & 6825 & 6079 & 5730 & 5102 & 4545 & 4056 & 3824 \\\hline
            Freq(Hex) & 1DEEH & 1AA9H & 17BFH & 1662H & 13EEH & 11C1 & FD8H & EF0H\\\hline
    \end{tabular}
\end{center}

\subsection*{Grundaufgabe a}
Der  Kanal  0  des  Timerbausteins  soll  als  programmierbarer  Frequenzgenerator  benutzt  werden.  Dazu  wird  die  Betriebsart  „Mode  3“  verwendet  (Frequenzteiler  mit  symmetrischer  Rechteckschwingung  am  Output).  Die  Output-Frequenz  soll  440  Hz  betragen. Als Input benutzen Sie den eingebauten 2-MHz-Generator.
$$\text{Zählkonstante: } \frac{2 MHz}{440 Hz} = 4545,4545 = (11C1)_{16}$$

\begin{lstlisting}
        MOV AL, 36H; Steuerbyte 00110110
        OUT 57H, AL
        MOV AL, 0C1H; LSB
        OUT 54H, Al
        MOV AL, 011H; MSB
        OUT 54H, AL
\end{lstlisting}

\subsection*{Grundaufgabe b}
Schalten  Sie  die  Tonausgabe  zunächst  wieder  ab  und  erweitern  Sie  das  Programm  um  die  Initialisierung der PIT-Kanäle 1 und 2. Die am Output des Kanals 2 angeschlossene LED soll mit  einer  Periodendauer  von  0,5s  blinken.  Es  ist  wiederum  Mode  3  zu  benutzen.  Da  beide  Kanäle hintereinander geschaltet (kaskadiert) sind, müssen Sie die benötigte Frequenzteilung auf beide Kanäle aufteilen. Außer der LED haben Sie diesmal keine weitere Kontrollmöglichkeit.

$$\text{Zählkonstante: } \frac{2 MHz}{2 Hz} /2 = 1000000 / 2 = 500000$$
\begin{lstlisting}
        MOV AL, 0B6H; Kanal 2
        OUT 57H, AL
        MOV AL, 0FFH
        OUT 56H, AL
        MOV AL, 0FFH
        OUT 56H, AL

        MOV AL, 076H ;Kanal 1
        OUT 57H, AL
        MOV AL, 0FFH
        OUT 55H, AL
        MOV AL, 0FFH
        OUT 56H, AL

\end{lstlisting}

\subsection*{Grundaufgabe c}
Die Tonausgabe von Kanal 0 wird wieder eingeschaltet. Sie soll jetzt aber nur noch dann aktiv sein, wenn gerade eine beliebige Taste in der blauen Tastenreihe gedrückt ist. Dazu müssen Sie in der Endlosschleife des Programms eine entsprechende Abfrage einbauen.

\begin{lstlisting}
noton:  MOV AL, 59H
        OUT 57H, AL
taste:  IN AL, 59H
        AND AL, 0FFH
        JZ noton        ;keine taste gedrueckt
        JMP ton
ton:    MOV AL, 0C1H
        OUT 54H, AL
        MOV AL, 011H
        OUT 54H, AL
        JMP taste
\end{lstlisting}

\subsection*{Fortgeschrittene Aufgabe d}
Erweitern Sie das Programm dann so, dass den einzelnen Tasten unterschiedliche Frequenzen zugeordnet sind. Es wird angenommen, dass nicht mehrere Tasten gleichzeitig gedrückt werden. Das  Blinken  der  LED  von  Aufgabe  b)  soll  weiterhin  funktionieren.

\begin{lstlisting}
noton:  MOV AL, 59H
        OUT 57H, AL
taste:  IN AL, 59H
        MOV BL, AL
        AND AL, 0FFH
        JZ noton        ;keine taste gedrueckt
        MOV AL, BL
        AND AL, 001H    ; Taste A
        JNZ tonA
        MOV AL, BL
        AND AL, 003H    ; Taste B
        JNZ tonB
        MOV AL, BL
        AND AL, 004H    ;Taste C
        JNZ tonC
        JMP taste
tonA:   MOV AL, 0C1H
        OUT 54H, AL
        MOV AL, 011H
        OUT 54H, AL
        JMP taste
tonB:   MOV AL, 008H
        OUT 54H, AL
        MOV AL, 0FDH
        OUT 54H, AL
        JMP taste
tonC:   MOV AL, 000H
        OUT 54H, AL
        MOV AL, 0EFH
        OUT 54H, AL
        JMP taste
\end{lstlisting}

\subsection*{Zusatzaufgabe}

\section*{A3: Matrixtastatur}
Eine 4x4 Matrixtastatur ist über Zeilen- und Spaltenleitungen verbunden. Um eine gedrückte Taste zu erkennen müssen alle Zeilen nacheinander abgefragt werden. Bei jedem Abfrageschnitt erhält man die Information über die gedrückten Tasten jeweils einer Zeile. 

\subsection*{Grundaufgabe a}
Alle Zeilen der Matrix je einmal abfragen und zurückkehren. Falls eine gedrückte Taste erkannt wurde, soll in einem gewählten Byteregister eine von Null verschiedene Tastennummer übergeben werden. 

Tastaturbelegung:
\begin{tabular}{c|c|c|c}
    1 & 2 & 3 & 4\\
    5 & 6 & 7 & 8\\
    9 &10 &11 &12\\
   13 &14 &15 &16
\end{tabular}
\begin{lstlisting}[caption= matr]
    
\end{lstlisting}

Wie \textit{matr} soll das Unterprogramm \textit{wmatr} alle Zeilen der Matrix abfragen aber erst beim Erkennen eines Tastendrucks zurückkehren. Das bedeutet, dass es das Drücken einer Taste abwartet und dann deren Nummer übergibt. 
\begin{lstlisting}[caption= wmatr]
    
\end{lstlisting}

Zur Durchführung sollen die Unterprogramme nacheinander in einem Hauptprogramm aufgerufen werden. Das Hauptprogramm selbst soll in einer "ewigen" Schleife arbeiten und die erkannte Tastennummer binär auf einer der LED-Zeilen anzeigen. 
\begin{lstlisting}[caption= mainA]
    
\end{lstlisting}


\subsection*{Grundaufgabe b}
Realisiere ein Programm, das die jeweils gedrückte Ziffer in lesbarer Darstellung auf der linken Stelle der Sieben-Segment-Anzeigen anzeigt. 
\begin{lstlisting}[caption= mainB]
    
\end{lstlisting}


\subsection*{Fortgeschrittene Aufgabe c}
Erweitere das Programm so dass gedrückte Ziffern der Reihe nach nebeneinander angezeigt werden und beim erreichen der letzten Stelle wieder links beginnt. 
Das Drücken einer nicht als Ziffer definierten Taste soll eine leere Stelle erzeugen.
\begin{lstlisting}[caption= mainC]
    
\end{lstlisting}


\subsection*{Fortgeschrittene Aufgabe d}
Verhindere das Prellen der Tasten durch Software um doppelte Tastendrücke zu vermeiden. 
\begin{lstlisting}[caption= mainD]
    
\end{lstlisting}

\subsection*{Zusatzaufgabe}
Realisiere einen einfachen Taschenrechner der einstellige nichtnegative Dezimalzahlen addiert und das ein- bis zweistellige Ergebnis auf der Sieben-Segment-Anzeige anzeigt. 
Definiere dafür Tasten für ,,+'' und ,,=''. 
\begin{tabular}{c|c|c|c}
    1 & 2 & 3 & 4\\
    5 & 6 & 7 & 8\\
    0 & 0 & 0 & 0\\
    + & 0 & 0 & = 
\end{tabular}

\begin{lstlisting}[caption= addition]
    
\end{lstlisting}

\end{document}